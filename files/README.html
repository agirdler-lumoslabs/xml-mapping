<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Aug 02 23:20:23 +0200 2011</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1><a href="../classes/XML.html">XML</a>-MAPPING: <a href="../classes/XML.html">XML</a>-to-object (and back) Mapper for Ruby, including XPath Interpreter</h1>
<p>
Xml-mapping is an easy to use, extensible library that allows you to
semi-automatically map Ruby objects to <a
href="../classes/XML.html">XML</a> trees and vice versa.
</p>
<h2>Download</h2>
<p>
For downloading the latest version, git repository access etc. go to:
</p>
<p>
<a
href="https://github.com/multi-io/xml-mapping">https://github.com/multi-io/xml-mapping</a>
</p>
<h2>Contents of this Document</h2>
<ul>
<li><a href="#example">Example</a>

</li>
<li><a href="#sanodes">Single-attribute Nodes</a>

<ul>
<li><a href="#defaultvalues">Default Values</a>

</li>
<li><a href="#subobjnodes">Single-attribute Nodes with Sub-objects</a>

</li>
<li><a href="#attrdefns">Attribute Handling Details, Augmenting Existing
Classes</a>

</li>
</ul>
</li>
<li><a href="#onodes">Other Nodes</a>

<ul>
<li><a href="#choice_node">choice_node</a>

</li>
<li><a href="#readerswriters">Readers/Writers</a>

</li>
</ul>
</li>
<li><a href="#mappings">Multiple Mappings per Class</a>

</li>
<li><a href="#definingnodes">Defining your own Node Types</a>

</li>
<li><a href="#xpath">XPath Interpreter</a>

</li>
</ul>
<h2><a name="example">Example</a></h2>
<p>
(example document stolen + extended from <a
href="http://www.castor.org/xml-mapping.html">www.castor.org/xml-mapping.html</a>)
</p>
<h3>Input Document:</h3>
<pre>
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

  &lt;Order reference=&quot;12343-AHSHE-314159&quot;&gt;
    &lt;Client&gt;
      &lt;Name&gt;Jean Smith&lt;/Name&gt;
      &lt;Address where=&quot;home&quot;&gt;
        &lt;City&gt;San Mateo&lt;/City&gt;
        &lt;State&gt;CA&lt;/State&gt;
        &lt;ZIP&gt;94403&lt;/ZIP&gt;
        &lt;Street&gt;2000, Alameda de las Pulgas&lt;/Street&gt;
      &lt;/Address&gt;
      &lt;Address where=&quot;work&quot;&gt;
        &lt;City&gt;San Francisco&lt;/City&gt;
        &lt;State&gt;CA&lt;/State&gt;
        &lt;ZIP&gt;94102&lt;/ZIP&gt;
        &lt;Street&gt;98765, Fulton Street&lt;/Street&gt;
      &lt;/Address&gt;
    &lt;/Client&gt;

    &lt;Item reference=&quot;RF-0001&quot;&gt;
      &lt;Description&gt;Stuffed Penguin&lt;/Description&gt;
      &lt;Quantity&gt;10&lt;/Quantity&gt;
      &lt;UnitPrice&gt;8.95&lt;/UnitPrice&gt;
    &lt;/Item&gt;

    &lt;Item reference=&quot;RF-0034&quot;&gt;
      &lt;Description&gt;Chocolate&lt;/Description&gt;
      &lt;Quantity&gt;5&lt;/Quantity&gt;
      &lt;UnitPrice&gt;28.50&lt;/UnitPrice&gt;
    &lt;/Item&gt;

    &lt;Item reference=&quot;RF-3341&quot;&gt;
      &lt;Description&gt;Cookie&lt;/Description&gt;
      &lt;Quantity&gt;30&lt;/Quantity&gt;
      &lt;UnitPrice&gt;0.85&lt;/UnitPrice&gt;
    &lt;/Item&gt;

    &lt;Signed-By&gt;
      &lt;Signature&gt;
        &lt;Name&gt;John Doe&lt;/Name&gt;
        &lt;Position&gt;product manager&lt;/Position&gt;
      &lt;/Signature&gt;

      &lt;Signature&gt;
        &lt;Name&gt;Jill Smith&lt;/Name&gt;
        &lt;Position&gt;clerk&lt;/Position&gt;
      &lt;/Signature&gt;

      &lt;Signature&gt;
        &lt;Name&gt;Miles O'Brien&lt;/Name&gt;
      &lt;/Signature&gt;
    &lt;/Signed-By&gt;

  &lt;/Order&gt;
</pre>
<h3>Mapping Class Declaration:</h3>
<pre>
  require 'xml/mapping'

  # forward declarations
  class Client; end
  class Address; end
  class Item; end
  class Signature; end

  class Order
    include XML::Mapping

    text_node :reference, &quot;@reference&quot;
    object_node :client, &quot;Client&quot;, :class=&gt;Client
    hash_node :items, &quot;Item&quot;, &quot;@reference&quot;, :class=&gt;Item
    array_node :signatures, &quot;Signed-By&quot;, &quot;Signature&quot;, :class=&gt;Signature, :default_value=&gt;[]

    def total_price
      items.values.map{|i| i.total_price}.inject(0){|x,y|x+y}
    end
  end

  class Client
    include XML::Mapping

    text_node :name, &quot;Name&quot;
    object_node :home_address, &quot;Address[@where='home']&quot;, :class=&gt;Address
    object_node :work_address, &quot;Address[@where='work']&quot;, :class=&gt;Address, :default_value=&gt;nil
  end

  class Address
    include XML::Mapping

    text_node :city, &quot;City&quot;
    text_node :state, &quot;State&quot;
    numeric_node :zip, &quot;ZIP&quot;
    text_node :street, &quot;Street&quot;
  end

  class Item
    include XML::Mapping

    text_node :descr, &quot;Description&quot;
    numeric_node :quantity, &quot;Quantity&quot;
    numeric_node :unit_price, &quot;UnitPrice&quot;

    def total_price
      quantity*unit_price
    end
  end

  class Signature
    include XML::Mapping

    text_node :name, &quot;Name&quot;
    text_node :position, &quot;Position&quot;, :default_value=&gt;&quot;Some Employee&quot;
  end
</pre>
<h3>Usage:</h3>
<pre>
  ###read access
  o=Order.load_from_file(&quot;order.xml&quot;)
  =&gt; #&lt;Order:0xb788f194 @client=#&lt;Client:0xb788e9d8 @work_address=#&lt;Address:0xb788c87c @state=&quot;CA&quot;, @city=&quot;San Francisco&quot;, @street=&quot;98765, Fulton Street&quot;, @zip=94102&gt;, @home_address=#&lt;Address:0xb788de48 @state=&quot;CA&quot;, @city=&quot;San Mateo&quot;, @street=&quot;2000, Alameda de las Pulgas&quot;, @zip=94403&gt;, @name=&quot;Jean Smith&quot;&gt;, @items={&quot;RF-3341&quot;=&gt;#&lt;Item:0xb7888c90 @quantity=30, @descr=&quot;Cookie&quot;, @unit_price=0.85&gt;, &quot;RF-0034&quot;=&gt;#&lt;Item:0xb7889e4c @quantity=5, @descr=&quot;Chocolate&quot;, @unit_price=28.5&gt;, &quot;RF-0001&quot;=&gt;#&lt;Item:0xb788b008 @quantity=10, @descr=&quot;Stuffed Penguin&quot;, @unit_price=8.95&gt;}, @reference=&quot;12343-AHSHE-314159&quot;, @signatures=[#&lt;Signature:0xb78875e8 @name=&quot;John Doe&quot;, @position=&quot;product manager&quot;&gt;, #&lt;Signature:0xb7886d78 @name=&quot;Jill Smith&quot;, @position=&quot;clerk&quot;&gt;, #&lt;Signature:0xb7886508 @name=&quot;Miles O'Brien&quot;, @position=&quot;Some Employee&quot;&gt;]&gt;
  o.reference
  =&gt; &quot;12343-AHSHE-314159&quot;
  o.client
  =&gt; #&lt;Client:0xb788e9d8 @work_address=#&lt;Address:0xb788c87c @state=&quot;CA&quot;, @city=&quot;San Francisco&quot;, @street=&quot;98765, Fulton Street&quot;, @zip=94102&gt;, @home_address=#&lt;Address:0xb788de48 @state=&quot;CA&quot;, @city=&quot;San Mateo&quot;, @street=&quot;2000, Alameda de las Pulgas&quot;, @zip=94403&gt;, @name=&quot;Jean Smith&quot;&gt;
  o.items.keys
  =&gt; [&quot;RF-3341&quot;, &quot;RF-0034&quot;, &quot;RF-0001&quot;]
  o.items[&quot;RF-0034&quot;].descr
  =&gt; &quot;Chocolate&quot;
  o.items[&quot;RF-0034&quot;].total_price
  =&gt; 142.5
  o.signatures
  =&gt; [#&lt;Signature:0xb78875e8 @name=&quot;John Doe&quot;, @position=&quot;product manager&quot;&gt;, #&lt;Signature:0xb7886d78 @name=&quot;Jill Smith&quot;, @position=&quot;clerk&quot;&gt;, #&lt;Signature:0xb7886508 @name=&quot;Miles O'Brien&quot;, @position=&quot;Some Employee&quot;&gt;]
  o.signatures[2].name
  =&gt; &quot;Miles O'Brien&quot;
  o.signatures[2].position
  =&gt; &quot;Some Employee&quot;
  # default value was set

  o.total_price
  =&gt; 257.5

  ###write access
  o.client.name=&quot;James T. Kirk&quot;
  o.items['RF-4711'] = Item.new
  o.items['RF-4711'].descr = 'power transfer grid'
  o.items['RF-4711'].quantity = 2
  o.items['RF-4711'].unit_price = 29.95

  s=Signature.new
  s.name='Harry Smith'
  s.position='general manager'
  o.signatures &lt;&lt; s
  xml=o.save_to_xml #convert to REXML node; there's also o.save_to_file(name)
  =&gt; &lt;order reference='12343-AHSHE-314159'&gt; ... &lt;/&gt;
  xml.write($stdout,2)
  &lt;order reference='12343-AHSHE-314159'&gt;
        &lt;Client&gt;
          &lt;Name&gt;James T. Kirk&lt;/Name&gt;
          &lt;Address where='home'&gt;
            &lt;City&gt;San Mateo&lt;/City&gt;
            &lt;State&gt;CA&lt;/State&gt;
            &lt;ZIP&gt;94403&lt;/ZIP&gt;
            &lt;Street&gt;2000, Alameda de las Pulgas&lt;/Street&gt;
          &lt;/Address&gt;
          &lt;Address where='work'&gt;
            &lt;City&gt;San Francisco&lt;/City&gt;
            &lt;State&gt;CA&lt;/State&gt;
            &lt;ZIP&gt;94102&lt;/ZIP&gt;
            &lt;Street&gt;98765, Fulton Street&lt;/Street&gt;
          &lt;/Address&gt;
        &lt;/Client&gt;
        &lt;Item reference='RF-3341'&gt;
          &lt;Description&gt;Cookie&lt;/Description&gt;
          &lt;Quantity&gt;30&lt;/Quantity&gt;
          &lt;UnitPrice&gt;0.85&lt;/UnitPrice&gt;
        &lt;/Item&gt;
        &lt;Item reference='RF-0034'&gt;
          &lt;Description&gt;Chocolate&lt;/Description&gt;
          &lt;Quantity&gt;5&lt;/Quantity&gt;
          &lt;UnitPrice&gt;28.5&lt;/UnitPrice&gt;
        &lt;/Item&gt;
        &lt;Item reference='RF-0001'&gt;
          &lt;Description&gt;Stuffed Penguin&lt;/Description&gt;
          &lt;Quantity&gt;10&lt;/Quantity&gt;
          &lt;UnitPrice&gt;8.95&lt;/UnitPrice&gt;
        &lt;/Item&gt;
        &lt;Item reference='RF-4711'&gt;
          &lt;Description&gt;power transfer grid&lt;/Description&gt;
          &lt;Quantity&gt;2&lt;/Quantity&gt;
          &lt;UnitPrice&gt;29.95&lt;/UnitPrice&gt;
        &lt;/Item&gt;
        &lt;Signed-By&gt;
          &lt;Signature&gt;
            &lt;Name&gt;John Doe&lt;/Name&gt;
            &lt;Position&gt;product manager&lt;/Position&gt;
          &lt;/Signature&gt;
          &lt;Signature&gt;
            &lt;Name&gt;Jill Smith&lt;/Name&gt;
            &lt;Position&gt;clerk&lt;/Position&gt;
          &lt;/Signature&gt;
          &lt;Signature&gt;
            &lt;Name&gt;Miles O&amp;apos;Brien&lt;/Name&gt;
          &lt;/Signature&gt;
          &lt;Signature&gt;
            &lt;Name&gt;Harry Smith&lt;/Name&gt;
            &lt;Position&gt;general manager&lt;/Position&gt;
          &lt;/Signature&gt;
        &lt;/Signed-By&gt;
      &lt;/order&gt;

  ###Starting a new order from scratch
  o = Order.new
  =&gt; #&lt;Order:0xb786ee58 @signatures=[]&gt;
  # attributes with default values (here: signatures) are set
  # automatically

  xml=o.save_to_xml
  XML::MappingError: no value, and no default value, for attribute: reference
        from ../lib/xml/../xml/mapping/base.rb:672:in `obj_to_xml'
        from ../lib/xml/../xml/mapping/base.rb:210:in `fill_into_xml'
        from ../lib/xml/../xml/mapping/base.rb:209:in `fill_into_xml'
        from ../lib/xml/../xml/mapping/base.rb:221:in `save_to_xml'
  # can't save as long as there are still unset attributes without
  # default values

  o.reference = &quot;FOOBAR-1234&quot;

  o.client = Client.new
  o.client.name = 'Ford Prefect'
  o.client.home_address = Address.new
  o.client.home_address.street = '42 Park Av.'
  o.client.home_address.city = 'small planet'
  o.client.home_address.zip = 17263
  o.client.home_address.state = 'Betelgeuse system'

  o.items={'XY-42' =&gt; Item.new}
  o.items['XY-42'].descr = 'improbability drive'
  o.items['XY-42'].quantity = 3
  o.items['XY-42'].unit_price = 299.95

  xml=o.save_to_xml
  xml.write($stdout,2)

  &lt;order reference='FOOBAR-1234'&gt;
        &lt;Client&gt;
          &lt;Name&gt;Ford Prefect&lt;/Name&gt;
          &lt;Address where='home'&gt;
            &lt;City&gt;small planet&lt;/City&gt;
            &lt;State&gt;Betelgeuse system&lt;/State&gt;
            &lt;ZIP&gt;17263&lt;/ZIP&gt;
            &lt;Street&gt;42 Park Av.&lt;/Street&gt;
          &lt;/Address&gt;
        &lt;/Client&gt;
        &lt;Item reference='XY-42'&gt;
          &lt;Description&gt;improbability drive&lt;/Description&gt;
          &lt;Quantity&gt;3&lt;/Quantity&gt;
          &lt;UnitPrice&gt;299.95&lt;/UnitPrice&gt;
        &lt;/Item&gt;
      &lt;/order&gt;
  # the root element name when saving an object to XML will by default
  # be derived from the class name (in this example, &quot;Order&quot; became
  # &quot;order&quot;). This can be overridden on a per-class basis; see
  # XML::Mapping::ClassMethods#root_element_name for details.
</pre>
<p>
As shown in the example, you have to include <a
href="../classes/XML/Mapping.html">XML::Mapping</a> into a class to turn it
into a &quot;mapping class&quot;. There are no other restrictions imposed
on mapping classes; you can add attributes and methods to them, include
additional modules in them, derive them from other classes, derive other
classes from them etc.pp.
</p>
<p>
An instance of a mapping class can be created from/converted into an <a
href="../classes/XML.html">XML</a> node with methods like <a
href="../classes/XML/Mapping/ClassMethods.html#M000031">XML::Mapping::ClassMethods.load_from_xml</a>,
<a href="../classes/XML/Mapping.html#M000020">XML::Mapping#save_to_xml</a>,
<a
href="../classes/XML/Mapping/ClassMethods.html#M000030">XML::Mapping::ClassMethods.load_from_file</a>,
<a
href="../classes/XML/Mapping.html#M000023">XML::Mapping#save_to_file</a>.
Special class methods like &quot;text_node&quot;, &quot;array_node&quot;
etc., called <b>node</b> <b>factory</b> <b>methods</b>, may be called from
the body of the class definition to define instance attributes that are
automatically and bidirectionally mapped to subtrees of the <a
href="../classes/XML.html">XML</a> element an instance of the class is
mapped to.
</p>
<h2><a name="sanodes">Single-attribute Nodes</a></h2>
<p>
For example, in the definition
</p>
<pre>
  class Address
    include XML::Mapping

    text_node :city, &quot;City&quot;
    text_node :state, &quot;State&quot;
    numeric_node :zip, &quot;ZIP&quot;
    text_node :street, &quot;Street&quot;
  end
</pre>
<p>
the first call to text_node creates an attribute named &quot;city&quot;
which is mapped to the text of the <a href="../classes/XML.html">XML</a>
child element defined by the XPath expression &quot;City&quot; (xml-mapping
includes an XPath interpreter that can also be used seperately; see <a
href="#xpath">below</a>). When you create an instance of <tt>Address</tt>
from an <a href="../classes/XML.html">XML</a> element (using
Address.load_from_file(file_name) or Address.load_from_xml(rexml_element)),
that instance&#8217;s &quot;city&quot; attribute will be set to the text of
the <a href="../classes/XML.html">XML</a> element&#8217;s &quot;City&quot;
child element. When you convert an instance of <tt>Address</tt> into an <a
href="../classes/XML.html">XML</a> element, a sub-element &quot;City&quot;
is added and its text is set to the current value of the <tt>city</tt>
attribute. The other node types (numeric_node, array_node etc.) work
analogously. Generally said, when an instance of the above <tt>Address</tt>
class is created from or converted to an <a
href="../classes/XML.html">XML</a> tree, each of the four nodes in the
class maps some parts of that <a href="../classes/XML.html">XML</a> tree to
a single, specific attribute of the <tt>Adress</tt> instance. The name of
that attribute is given in the first argument to the node factory method.
Such a node is called a &quot;single-attribute node&quot;. All node types
that come with xml-mapping except one (<tt>choice_node</tt>, which
I&#8217;ll talk about below) are single-attribute nodes.
</p>
<h3><a name="defaultvalues">Default Values</a></h3>
<p>
For each single-attribute node you may define a <em>default value</em>
which will be set if there was no value defined for the attribute in the <a
href="../classes/XML.html">XML</a> source.
</p>
<p>
From the example:
</p>
<pre>
  class Signature
    include XML::Mapping

    text_node :position, &quot;Position&quot;, :default_value=&gt;&quot;Some Employee&quot;
  end
</pre>
<p>
The semantics of default values are as follows:
</p>
<ul>
<li>when creating a new instance from scratch:

<ul>
<li>attributes with default values are set to their default values

</li>
<li>attributes without default values are left unset

</li>
</ul>
<p>
(when defining your own initializer, you&#8217;ll have to call the
inherited <em>initialize</em> method in order to get this behaviour)
</p>
</li>
<li>when loading an instance from an <a href="../classes/XML.html">XML</a>
document:

<ul>
<li>attributes without default values that are not represented in the <a
href="../classes/XML.html">XML</a> raise an error

</li>
<li>attributes with default values that are not represented in the <a
href="../classes/XML.html">XML</a> are set to their default values

</li>
<li>all other attributes are set to their respective values as present in the
<a href="../classes/XML.html">XML</a>

</li>
</ul>
</li>
<li>when saving an instance to an <a href="../classes/XML.html">XML</a>
document:

<ul>
<li>unset attributes without default values raise an error

</li>
<li>attributes with default values that are set to their default values are not
saved

</li>
<li>all other attributes are saved

</li>
</ul>
</li>
</ul>
<p>
This implies that:
</p>
<ul>
<li>attributes that are set to their respective default values are not
represented in the <a href="../classes/XML.html">XML</a>

</li>
<li>attributes without default values must be set explicitly before saving

</li>
</ul>
<h3><a name="subobjnodes">Single-attribute Nodes with Sub-objects</a></h3>
<p>
Single-attribute nodes of type <tt>array_node</tt>, <tt>hash_node</tt>, and
<tt>object_node</tt> recursively map one or more subtrees of their <a
href="../classes/XML.html">XML</a> to sub-objects (e.g. array elements or
hash values) of their attribute. For example, with the line
</p>
<pre>
  array_node :signatures, &quot;Signed-By&quot;, &quot;Signature&quot;, :class=&gt;Signature, :default_value=&gt;[]
</pre>
<p>
, an attribute named &quot;signatures&quot; is added to the surrounding
class (here: <tt>Order</tt>); the attribute will be an array whose elements
correspond to the <a href="../classes/XML.html">XML</a> sub-trees yielded
by the XPath expression &quot;Signed-By/Signature&quot; (relative to the
tree corresponding to the <tt>Order</tt> instance). Each element will be of
class <tt>Signature</tt> (internally, each element is created from its
corresponding <a href="../classes/XML.html">XML</a> subtree by just calling
<tt>Signature.load_from_xml(the_subtree)</tt>). The reason why the path
&quot;Signed-By/Signature&quot; is provided in two arguments instead of
just one combined one becomes apparent when marshalling the array (along
with the surrounding <tt>Order</tt> object) back into a sequence of <a
href="../classes/XML.html">XML</a> elements. When that happens,
&quot;Signed-By&quot; names the common base element for all those elements,
and &quot;Signature&quot; is the path that will be duplicated for each
element. For example, when the <tt>signatures</tt> attribute contains an
array with 3 <tt>Signature</tt> instances (let&#8217;s call them
<tt>sig1</tt>, <tt>sig2</tt>, and <tt>sig3</tt>) in it, it will be
marshalled to an <a href="../classes/XML.html">XML</a> tree that looks like
this:
</p>
<pre>
  &lt;Signed-By&gt;
    &lt;Signature&gt;
      [marshalled object sig1]
    &lt;/Signature&gt;
    &lt;Signature&gt;
      [marshalled object sig2]
    &lt;/Signature&gt;
    &lt;Signature&gt;
      [marshalled object sig3]
    &lt;/Signature&gt;
  &lt;/Signed-By&gt;
</pre>
<p>
Internally, each <tt>Signature</tt> instance is stored into its
<tt>&lt;Signature&gt;</tt> sub-element by calling
<tt>the_signature_instance.fill_into_xml(the_sub_element)</tt>. The input
document in the example above shows how this ends up looking.
</p>
<p>
<tt>hash_node</tt>s work similarly, but they define hash-valued attributes
instead of array-valued ones.
</p>
<p>
<tt>object_node</tt>s are the simplest of the three types of
single-attribute nodes with sub-objects. They just map a single given
subtree directly to their attribute value. See the example for examples :)
</p>
<p>
The mentioned methods <tt>load_from_xml</tt> and <tt>fill_into_xml</tt> are
the only methods classes must implement in order to be usable in the
<tt>:class=&gt;</tt> keyword arguments to node factory methods. Mapping
classes (i.e. classes that <tt>include <a
href="../classes/XML/Mapping.html">XML::Mapping</a></tt>) automatically
inherit those functions and can thus be readily used in
<tt>:class=&gt;</tt> arguments, as shown for the <tt>Signature</tt> class
in the <tt>array_node</tt> call above. In addition to that, xml-mapping
adds those methods to some of Ruby&#8217;s core classes, namely <tt><a
href="../classes/String.html">String</a></tt> and <tt><a
href="../classes/Numeric.html">Numeric</a></tt> (and thus <tt>Float</tt>,
<tt>Integer</tt>, and <tt>BigInt</tt>). So you can also use strings or
numbers as sub-objects of attributes of <tt>array_node</tt>,
<tt>hash_node</tt>, or <tt>object_node</tt> nodes. For example, say you
have an <a href="../classes/XML.html">XML</a> document like this one:
</p>
<pre>
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

  &lt;people&gt;
    &lt;names&gt;
      &lt;name&gt;Jim&lt;/name&gt;
      &lt;name&gt;Susan&lt;/name&gt;
      &lt;name&gt;Herbie&lt;/name&gt;
      &lt;name&gt;Nancy&lt;/name&gt;
    &lt;/names&gt;
  &lt;/people&gt;
</pre>
<p>
, and you want to map all the names to a string array attribute
<tt>names</tt>, you could do it like this:
</p>
<pre>
  require 'xml/mapping'
  class People
    include XML::Mapping
    array_node :names, &quot;names&quot;, &quot;name&quot;, :class=&gt;String
  end
</pre>
<p>
usage:
</p>
<pre>
  ppl=People.load_from_file(&quot;stringarray.xml&quot;)
  =&gt; #&lt;People:0xb7bd8174 @names=[&quot;Jim&quot;, &quot;Susan&quot;, &quot;Herbie&quot;, &quot;Nancy&quot;]&gt;
  ppl.names
  =&gt; [&quot;Jim&quot;, &quot;Susan&quot;, &quot;Herbie&quot;, &quot;Nancy&quot;]

  ppl.names.concat [&quot;Mary&quot;,&quot;Arnold&quot;]
  =&gt; [&quot;Jim&quot;, &quot;Susan&quot;, &quot;Herbie&quot;, &quot;Nancy&quot;, &quot;Mary&quot;, &quot;Arnold&quot;]
  ppl.save_to_xml.write $stdout,2

  &lt;people&gt;
        &lt;names&gt;
          &lt;name&gt;Jim&lt;/name&gt;
          &lt;name&gt;Susan&lt;/name&gt;
          &lt;name&gt;Herbie&lt;/name&gt;
          &lt;name&gt;Nancy&lt;/name&gt;
          &lt;name&gt;Mary&lt;/name&gt;
          &lt;name&gt;Arnold&lt;/name&gt;
        &lt;/names&gt;
      &lt;/people&gt;
</pre>
<p>
As a side node, this feature actually makes <tt>text_node</tt> and
<tt>numeric_node</tt> special cases of <tt>object_node</tt>. For example,
<tt>text_node :attr, &quot;path&quot;</tt> is the same as <tt>object_node
:attr, &quot;path&quot;, :class=&gt;<a
href="../classes/String.html">String</a></tt>.
</p>
<h4>Polymorphic Sub-objects, Marshallers/Unmarshallers</h4>
<p>
Besides the <tt>:class</tt> keyword argument, there are alternative ways
for a single-attribute node with sub-objects to specify the way the
sub-objects are created from/marshalled into their subtrees.
</p>
<p>
First, it&#8217;s possible not to specify anything at all &#8212; in that
case, the class of a sub-object will be automatically deduced from the root
element name of its subtree. This allows you to achieve a kind of
&quot;polymorphic&quot;, late-bound way to decide about the
sub-object&#8217;s class. The following example document contains a
hierarchical, recursive set of named &quot;documents&quot; and
&quot;folders&quot;, where folders hold a set of entries, each of which may
again be either a document or a folder:
</p>
<pre>
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

  &lt;folder name=&quot;home&quot;&gt;
    &lt;document name=&quot;plan&quot;&gt;
      &lt;contents&gt; inhale, exhale&lt;/contents&gt;
    &lt;/document&gt;

    &lt;folder name=&quot;work&quot;&gt;
      &lt;folder name=&quot;xml-mapping&quot;&gt;
        &lt;document name=&quot;README&quot;&gt;
          &lt;contents&gt;foo bar baz&lt;/contents&gt;
        &lt;/document&gt;
      &lt;/folder&gt;
    &lt;/folder&gt;

  &lt;/folder&gt;
</pre>
<p>
This can be mapped to Ruby like this:
</p>
<pre>
  require 'xml/mapping'

  class Entry
    include XML::Mapping

    text_node :name, &quot;@name&quot;
  end

  class Document &lt;Entry
    include XML::Mapping

    text_node :contents, &quot;contents&quot;
  end

  class Folder &lt;Entry
    include XML::Mapping

    array_node :entries, &quot;document|folder&quot;, :default_value=&gt;[]

    def [](name)
      entries.select{|e|e.name==name}[0]
    end

    def append(name,entry)
      entries &lt;&lt; entry
      entry.name = name
      entry
    end
  end
</pre>
<p>
Usage:
</p>
<pre>
  root = XML::Mapping.load_object_from_file &quot;documents_folders.xml&quot;
  =&gt; #&lt;Folder:0xb7a2b584 @entries=[#&lt;Document:0xb7a2ab5c @contents=&quot; inhale, exhale&quot;, @name=&quot;plan&quot;&gt;, #&lt;Folder:0xb7a2a238 @entries=[#&lt;Folder:0xb7a29900 @entries=[#&lt;Document:0xb7a28ff0 @contents=&quot;foo bar baz&quot;, @name=&quot;README&quot;&gt;], @name=&quot;xml-mapping&quot;&gt;], @name=&quot;work&quot;&gt;], @name=&quot;home&quot;&gt;
  root.name
  =&gt; &quot;home&quot;
  root.entries
  =&gt; [#&lt;Document:0xb7a2ab5c @contents=&quot; inhale, exhale&quot;, @name=&quot;plan&quot;&gt;, #&lt;Folder:0xb7a2a238 @entries=[#&lt;Folder:0xb7a29900 @entries=[#&lt;Document:0xb7a28ff0 @contents=&quot;foo bar baz&quot;, @name=&quot;README&quot;&gt;], @name=&quot;xml-mapping&quot;&gt;], @name=&quot;work&quot;&gt;]

  root.append &quot;etc&quot;, Folder.new
  root[&quot;etc&quot;].append &quot;passwd&quot;, Document.new
  root[&quot;etc&quot;][&quot;passwd&quot;].contents = &quot;foo:x:2:2:/bin/sh&quot;
  root[&quot;etc&quot;].append &quot;hosts&quot;, Document.new
  root[&quot;etc&quot;][&quot;hosts&quot;].contents = &quot;127.0.0.1 localhost&quot;

  xml = root.save_to_xml
  =&gt; &lt;folder name='home'&gt; ... &lt;/&gt;
  xml.write $stdout,2

  &lt;folder name='home'&gt;
        &lt;document name='plan'&gt;
          &lt;contents&gt; inhale, exhale&lt;/contents&gt;
        &lt;/document&gt;
        &lt;folder name='work'&gt;
          &lt;folder name='xml-mapping'&gt;
            &lt;document name='README'&gt;
              &lt;contents&gt;foo bar baz&lt;/contents&gt;
            &lt;/document&gt;
          &lt;/folder&gt;
        &lt;/folder&gt;
        &lt;folder name='etc'&gt;
          &lt;document name='passwd'&gt;
            &lt;contents&gt;foo:x:2:2:/bin/sh&lt;/contents&gt;
          &lt;/document&gt;
          &lt;document name='hosts'&gt;
            &lt;contents&gt;127.0.0.1 localhost&lt;/contents&gt;
          &lt;/document&gt;
        &lt;/folder&gt;
      &lt;/folder&gt;
</pre>
<p>
As you see, the <tt>Folder#entries</tt> attribute is mapped via an
array_node that does not specify a <tt>:class</tt> or anything else to
govern the instantiation of the array&#8217;s elements. This causes
xml-mapping to deduce the class of each array element from the root element
name of the corresponding <a href="../classes/XML.html">XML</a> tree. In
this example, the root element name is either &quot;document&quot; or
&quot;folder&quot;. The mapping between root element names and class names
is the one briefly described in <a href="#example">example</a> at the
beginning of this document &#8212; the unqualified class name is just
converted to lower case and &quot;dashed&quot;, e.g. Foo::Bar::MyClass
becomes &quot;my-class&quot;; and you may overwrite this on a per-class
basis by calling <tt>root_element_name &quot;the-new-name&quot;</tt> in the
class body. In our example, the root element name &quot;document&quot;
leads to an instantiation of class <tt>Document</tt>, and the root element
name &quot;folder&quot; leads to an instantiation of class <tt>Folder</tt>.
</p>
<p>
Incidentally, the last example shows that you can readily derive mapping
classes from one another (as said before, you can also derive mapping
classes from other classes, include other modules into them etc. at will).
This works just like intuition thinks it should &#8212; when deriving one
mapping class from another one, the list of nodes in effect when
loading/saving instances of the derived class will consist of all nodes of
that class and all superclasses, starting with the topmost superclass that
has nodes defined. There is one thing to take care of though: When deriving
mapping classes from one another, you have to make sure to <tt>include <a
href="../classes/XML/Mapping.html">XML::Mapping</a></tt> in each class.
This requirement exists purely due to ease-of-implementation
considerations; there are probably ways to do away with it, but the
inconvenience seemed not severe enough for me to bother (as yet). Still,
you might get &quot;strange&quot; errors if you forget to do it for a
class.
</p>
<p>
Besides the <tt>:class</tt> keyword argument and no argument, there is a
third way to specify the way the sub-objects are created from/marshalled
into their subtrees: <tt>:marshaller</tt> and/or <tt>:unmarshaller</tt>
keyword arguments. Here you pass procs in which you just do all the work
manually. So this is basically a &quot;catch-all&quot; for cases where the
other two alternatives are not appropriate for the problem at hand.
(<b>TODO</b>: Use other example?) Let&#8217;s say we want to extend the
<tt>Signature</tt> class from the initial example to include the date on
which the signature was created. We want the new <a
href="../classes/XML.html">XML</a> representation of such a signature to
look like this:
</p>
<pre>
  &lt;Signature&gt;
    &lt;Name&gt;John Doe&lt;/Name&gt;
    &lt;Position&gt;product manager&lt;/Position&gt;
    &lt;signed-on&gt;
      &lt;day&gt;13&lt;/day&gt;
      &lt;month&gt;2&lt;/month&gt;
      &lt;year&gt;2005&lt;/year&gt;
    &lt;/signed-on&gt;
  &lt;/Signature&gt;
</pre>
<p>
So, a new &quot;signed-on&quot; element was added that holds the day,
month, and year. In the <tt>Signature</tt> instance in Ruby, we want the
date to be stored in an attribute named <tt>signed_on</tt> of type
<tt>Time</tt> (that&#8217;s Ruby&#8217;s built-in <tt>Time</tt> class).
</p>
<p>
One could think of using <tt>object_node</tt>, but something like
<tt>object_node :signed_on, &quot;signed-on&quot;, :class=&gt;Time</tt>
won&#8217;t work because <tt>Time</tt> isn&#8217;t a mapping class and
doesn&#8217;t define methods <tt>load_from_xml</tt> and
<tt>fill_into_xml</tt> (we could easily define those though; we&#8217;ll
talk about that possibility <a href="#attrdefns">here</a> and <a
href="#definingnodes">here</a>). The fastest, most ad-hoc way to achieve
what we want are :marshaller and :unmarshaller keyword arguments, like
this:
</p>
<pre>
  require 'xml/mapping'
  require 'xml/xxpath_methods'

  class Signature
    include XML::Mapping

    text_node :name, &quot;Name&quot;
    text_node :position, &quot;Position&quot;, :default_value=&gt;&quot;Some Employee&quot;
    object_node :signed_on, &quot;signed-on&quot;,
                :unmarshaller=&gt;proc{|xml|
                                 y,m,d = [xml.first(&quot;year&quot;).text.to_i,
                                          xml.first(&quot;month&quot;).text.to_i,
                                          xml.first(&quot;day&quot;).text.to_i]
                                 Time.local(y,m,d)
                               },
                :marshaller=&gt;proc{|xml,value|
                               e = xml.elements.add; e.name = &quot;year&quot;; e.text = value.year
                               e = xml.elements.add; e.name = &quot;month&quot;; e.text = value.month
                               e = xml.elements.add; e.name = &quot;day&quot;; e.text = value.day

                               # xml.first(&quot;year&quot;,:ensure_created=&gt;true).text = value.year
                               # xml.first(&quot;month&quot;,:ensure_created=&gt;true).text = value.month
                               # xml.first(&quot;day&quot;,:ensure_created=&gt;true).text = value.day
                             }
  end
</pre>
<p>
The <tt>:unmarshaller</tt> proc will be called whenever a
<tt>Signature</tt> instance is being read in from an <a
href="../classes/XML.html">XML</a> source. The <tt>xml</tt> argument passed
to the proc contains (as a REXML::Element instance) the <a
href="../classes/XML.html">XML</a> subtree corresponding to the
node&#8217;s attribute&#8217;s sub-object currently being read. In the case
of our <tt>object_node</tt>, the sub-object is just the node&#8217;s
attribute (<tt>signed_on</tt>) itself, and the subtree is the one rooted at
the &lt;signed-on&gt; element (if this were e.g. an <tt>array_node</tt>,
the <tt>:unmarshaller</tt> proc would be called once for each array
element, and <tt>xml</tt> would hold the subtree corresponding to the
&quot;current&quot; array element). The proc is expected to extract the
sub-object&#8217;s data from <tt>xml</tt> and return the sub-object. So we
have to read the &quot;year&quot;, &quot;month&quot;, and &quot;day&quot;
elements, construct a <tt>Time</tt> instance from them and return that. One
could just use the <a href="../classes/REXML.html">REXML</a> API to do
that, but I&#8217;ve decided here to use the XPath interpreter that comes
with xml-mapping (xml/xxpath), and specifically the
&#8216;xml/xxpath_methods&#8217; utility library that adds methods like
<tt>first</tt> to REMXML::Element. We call <tt>first</tt> on <tt>xml</tt>
three times, passing XPath expressions to extract the
&quot;year&quot;/&quot;month&quot;/&quot;day&quot; sub-elements, construct
the <tt>Time</tt> instance from that and return it. The XPath library is
explained in more detail <a href="#xpath">below</a>.
</p>
<p>
The <tt>:marshaller</tt> proc will be called whenever a <tt>Signature</tt>
instance is being written into an <a href="../classes/XML.html">XML</a>
tree. <tt>xml</tt> is again the <a href="../classes/XML.html">XML</a>
subtree rooted at the &lt;signed-on&gt; element (it will still be empty
when this proc is called), and <tt>value</tt> is the current value of the
sub-object (again, since this is an <tt>object_node</tt>, <tt>value</tt> is
the node&#8217;s attribute, i.e. the <tt>Time</tt> instance). We have to
fill <tt>xml</tt> with the data from <tt>value</tt> here. So we add three
elements &quot;year&quot;, &quot;month&quot; and &quot;day&quot; and set
their texts to the corresponding values from <tt>value</tt>. The
commented-out code shows an alternative implementation of the same thing
using the XPath interpreter.
</p>
<p>
It should be mentioned again that :marshaller/:unmarshaller procs are
possible with all single-attribute nodes with sub-objects, i.e. with
<tt>object_node</tt>, <tt>array_node</tt>, and <tt>hash_node</tt>. So, if
you wanted to map a whole array of date values, you could use
<tt>array_node</tt> with the same :marshaller/:unmarshaller procs as above,
for example:
</p>
<pre>
  array_node :birthdays, &quot;birthdays&quot;, &quot;birthday&quot;,
             :unmarshaller=&gt; &lt;as above&gt;,
             :marshaller=&gt; &lt;as above&gt;
</pre>
<p>
You can see that :marshaller/:unmarshaller procs give you more flexibility,
but they also impose more work because you essentially have to do all the
work of marshalling/unmarshalling the sub-objects yourself. If you find
yourself copying and pasting marshaller/unmarshaller procs all over the
place, you should instead define your own node type or mix the
marshalling/unmarshalling capabilities into the <tt>Time</tt> class itself.
This is explained <a href="#attrdefns">here</a> and <a
href="#definingnodes">here</a>, and you&#8217;ll see that it&#8217;s not
really much more work than writing :marshaller and :unmarshaller procs (you
essentially just move the code from those procs into your own node type
resp. into the <tt>Time</tt> class), so you should not hesitate to do this.
</p>
<p>
Another thing worth mentioning is that you don&#8217;t have to specify
<b>both</b> a :marshaller and an :unmarshaller simultaneously. You can as
well give only one of them, and in addition to that pass a <tt>:class</tt>
argument or no argument. When you do that, the specified marshaller (or
unmarshaller) will be used when marshalling (resp. unmarshalling) the
sub-objects, and the other passed argument (<tt>:class</tt> or none) will
be employed when unmarshalling (resp. marshalling) the sub-objects. So, in
effect, you can deactivate or &quot;short-cut&quot; some part of the
marshalling/unmarshalling functionality of a node type while retaining
another part.
</p>
<h3><a name="attrdefns">Attribute Handling Details, Augmenting Existing Classes</a></h3>
<p>
I&#8217;ll shed some more light on how single-attribute nodes add mapped
attributes to Ruby classes. An attribute declaration like
</p>
<pre>
  text_node :city, &quot;City&quot;
</pre>
<p>
maps some portion of the <a href="../classes/XML.html">XML</a> tree (here:
the &quot;City&quot; sub-element) to an attribute (here: &quot;city&quot;)
of the class whose body the declaration appears in. When writing
(marshalling) instances of the surrounding class into an <a
href="../classes/XML.html">XML</a> document, xml-mapping will read the
attribute value from the instance using the function named <tt>city</tt>;
when reading (unmarshalling) an instance from an <a
href="../classes/XML.html">XML</a> document, xml-mapping will use the
one-parameter function <tt>city=</tt> to set the attribute in the instance
to the value read from the <a href="../classes/XML.html">XML</a> document.
</p>
<p>
If these functions don&#8217;t exist at the time the node declaration is
executed, xml-mapping adds default implementations that simply read/write
the attribute value to instance variables that have the same name as the
attribute. For example, the <tt>city</tt> attribute declaration in the
<tt>Address</tt> class in the example added functions <tt>city</tt> and
<tt>city=</tt> that read/write from/to the instance variable
<tt>@city</tt>.
</p>
<p>
If, however, these functions already exist prior to defining the
attributes, xml-mapping will leave them untouched, so your precious
self-written accessor methods that do whatever complicated internal
processing of the data won&#8217;t be overwritten.
</p>
<p>
This means that you can not only create new mapping classes from scratch,
you can also take existing classes that contain some &quot;business
logic&quot; and &quot;augment&quot; them with xml-mapping capabilities. As
a simple example, let&#8217;s augment Ruby&#8217;s &quot;Time&quot; class
with node declarations that declare <a href="../classes/XML.html">XML</a>
mappings for the day, month etc. fields:
</p>
<pre>
  class Time
    include XML::Mapping

    numeric_node :year, &quot;year&quot;
    numeric_node :month, &quot;month&quot;
    numeric_node :day, &quot;mday&quot;
    numeric_node :hour, &quot;hours&quot;
    numeric_node :min, &quot;minutes&quot;
    numeric_node :sec, &quot;seconds&quot;
  end

  nowxml=Time.now.save_to_xml
  =&gt; &lt;time&gt; ... &lt;/&gt;
  nowxml.write($stdout,2)
  &lt;time&gt;
        &lt;year&gt;2006&lt;/year&gt;
        &lt;month&gt;8&lt;/month&gt;
        &lt;mday&gt;8&lt;/mday&gt;
        &lt;hours&gt;0&lt;/hours&gt;
        &lt;minutes&gt;36&lt;/minutes&gt;
        &lt;seconds&gt;27&lt;/seconds&gt;
      &lt;/time&gt;
</pre>
<p>
Here <a href="../classes/XML.html">XML</a> mappings are defined for the
existing fields <tt>year</tt>, <tt>month</tt> etc. Xml-mapping noticed that
the getter methods for those attributes existed, so it didn&#8217;t
overwrite them. When calling <tt>save_to_xml</tt> on a <tt>Time</tt>
object, these methods are called and return the object&#8217;s values for
those fields, which then get written to the output <a
href="../classes/XML.html">XML</a>.
</p>
<p>
So you can convert <tt>Time</tt> objects into <a
href="../classes/XML.html">XML</a> trees. What about reading them back in
from <a href="../classes/XML.html">XML</a>? All <a
href="../classes/XML.html">XML</a> reading operations go through
<tt>&lt;Class&gt;.load_from_xml</tt>. The <tt>load_from_xml</tt> class
method inherited from <a
href="../classes/XML/Mapping.html">XML::Mapping</a> (see <a
href="../classes/XML/Mapping/ClassMethods.html#M000031">XML::Mapping::ClassMethods#load_from_xml</a>)
allocates a new instance of the class (<tt>Time</tt>), then calls
<tt>fill_from_xml</tt> (i.e. <a
href="../classes/XML/Mapping.html#M000016">XML::Mapping#fill_from_xml</a>)
on it. <tt>fill_from_xml</tt> iterates over all our nodes in the order of
their definition. For each node, its data (the &lt;year&gt;, or
&lt;month&gt;, or &lt;day&gt; etc. element) is read from the <a
href="../classes/XML.html">XML</a> source and then written to the
<tt>Time</tt> instance via the respective setter method (<tt>year=</tt>,
<tt>month=</tt>, <tt>day=</tt> etc.). These methods didn&#8217;t exist in
<tt>Time</tt> before (<tt>Time</tt> objects are immutable), so xml-mapping
defined its own, default setter methods that just set <tt>@year</tt>,
<tt>@month</tt> etc. This is of course pretty useless because <tt>Time</tt>
objects don&#8217;t hold their time in these variables, so the setter
methods don&#8217;t really change the time of the <tt>Time</tt> object. So
we have to redefine <tt>load_from_xml</tt> for the <tt>Time</tt> class:
</p>
<pre>
  def Time.load_from_xml(xml, options={:mapping=&gt;:_default})
    year,month,day,hour,min,sec =
      [xml.first(&quot;year&quot;).text.to_i,
       xml.first(&quot;month&quot;).text.to_i,
       xml.first(&quot;mday&quot;).text.to_i,
       xml.first(&quot;hours&quot;).text.to_i,
       xml.first(&quot;minutes&quot;).text.to_i,
       xml.first(&quot;seconds&quot;).text.to_i]
    Time.local(year,month,day,hour,min,sec)
  end
</pre>
<h2><a name="onodes">Other Nodes</a></h2>
<p>
All nodes I&#8217;ve shown so far (node types text_node, numeric_node,
boolean_node, object_node, array_node, and hash_node) were single-attribute
nodes: The first parameter to the node factory method of such a node is an
attribute name, and the attribute of that name is the only piece of the
state of instances of the node&#8217;s mapping class that gets read/written
by the node.
</p>
<h3><a name="choice_node">choice_node</a></h3>
<p>
There is one node type distributed with xml-mapping that is not a
single-attribute node: <tt>choice_node</tt>. A <tt>choice_node</tt> allows
you to specify a sequence of pairs, each consisting of an XPath expression
and another node (any node is supported here, including other
choice_nodes). When reading in an <a href="../classes/XML.html">XML</a>
source, the choice_node will delegate the work to the first node in the
sequence whose corresponding XPath expression was matched in the <a
href="../classes/XML.html">XML</a>. When writing an object back to <a
href="../classes/XML.html">XML</a>, the choice_node will delegate the work
to the first node whose data was &quot;present&quot; in the object (for
single-attribute nodes, the data is considered &quot;present&quot; if the
node&#8217;s attribute is non-nil; for choice_nodes, the data is considered
&quot;present&quot; if at least one of the node&#8217;s sub-nodes is
&quot;present&quot;).
</p>
<p>
As a (somewhat contrived) example, here&#8217;s a mapping for
<tt>Publication</tt> objects that have either a single author (contained in
an &quot;author&quot; <a href="../classes/XML.html">XML</a> attribute) or
several &quot;contributors&quot; (contained in a sequence of
&quot;contr&quot; <a href="../classes/XML.html">XML</a> elements):
</p>
<pre>
  class Publication
    include XML::Mapping

    choice_node :if,    '@author', :then, (text_node :author, '@author'),
                :elsif, 'contr',   :then, (array_node :contributors, 'contr', :class=&gt;String)
  end

  ## usage

  p1 = Publication.load_from_xml(REXML::Document.new('&lt;publication author=&quot;Jim&quot;/&gt;').root)
  =&gt; #&lt;Publication:0xb78b0088 @author=&quot;Jim&quot;&gt;

  p2 = Publication.load_from_xml(REXML::Document.new('
  &lt;publication&gt;
    &lt;contr&gt;Chris&lt;/contr&gt;
    &lt;contr&gt;Mel&lt;/contr&gt;
    &lt;contr&gt;Toby&lt;/contr&gt;
  &lt;/publication&gt;').root)
  =&gt; #&lt;Publication:0xb78ae38c @contributors=[&quot;Chris&quot;, &quot;Mel&quot;, &quot;Toby&quot;]&gt;
</pre>
<p>
The symbols :if, :then, and :elsif (but not :else &#8212; see below) in the
<tt>choice_node</tt>&#8217;s node factory method call are ignored; they may
be sprinkled across the argument list at will (preferably the way shown
above of course) to increase readability.
</p>
<p>
The rest of the arguments specify the mentioned sequence of XPath
expressions and corresponding nodes.
</p>
<p>
When reading a <tt>Publication</tt> object from <a
href="../classes/XML.html">XML</a>, the XPath expressions from the
<tt>choice_node</tt> (<tt>@author</tt> and <tt>contr</tt>) will be matched
in sequence against the source <a href="../classes/XML.html">XML</a> tree
until a match is found or the end of the argument list is reached. If the
end is reached, an exception is raised. Otherwise, for the first XPath
expression that matched, the corresponding node will be invoked (i.e. used
to read actual data from the <a href="../classes/XML.html">XML</a> source
into the <tt>Person</tt> object). If you specify :else, :default, or
:otherwise in place of an XPath expression, this is treated as an XPath
expression that always matches. So you can use :else (or :default or
:otherwise) for a &quot;fallback&quot; node that will be used if none of
the other XPath expressions matched (an example for this follows).
</p>
<p>
When writing a <tt>Publication</tt> object back to <a
href="../classes/XML.html">XML</a>, the first node in the sequence whose
data is &quot;present&quot; in the source object will be invoked to write
data from the object into the target <a href="../classes/XML.html">XML</a>
tree (and the corresponding XPath expression will be created in the <a
href="../classes/XML.html">XML</a> tree if it doesn&#8217;t exist already).
If there is no such node in the sequence, an exception is raised. As said
above, for single-attribute nodes, the node&#8217;s data is considered
&quot;present&quot; if the node&#8217;s attribute is non-nil. So, if you
write a <tt>Publication</tt> object to <a
href="../classes/XML.html">XML</a>, and either the <tt>author</tt> or the
<tt>contributors</tt> attribute of the object is set, it will be written;
if both attributes are nil, an exception will be raised.
</p>
<p>
A frequent use case for choice_nodes will probably be object attributes
that may be represented in multiple alternative ways in <a
href="../classes/XML.html">XML</a>. As an example, consider
&quot;Person&quot; objects where the name of the person should be stored
alternatively in a sub-element named <tt>name</tt>, or an attribute named
<tt>name</tt>, or in the text of the <tt>person</tt> element itself. You
can achieve this with <tt>choice_node</tt> like this:
</p>
<pre>
  class Person
    include XML::Mapping

    choice_node :if,    'name',  :then, (text_node :name, 'name'),
                :elsif, '@name', :then, (text_node :name, '@name'),
                :else,  (text_node :name, '.')
  end

  ## usage

  p1 = Person.load_from_xml(REXML::Document.new('&lt;person name=&quot;Jim&quot;/&gt;').root)
  =&gt; #&lt;Person:0xb78bd940 @name=&quot;Jim&quot;&gt;

  p2 = Person.load_from_xml(REXML::Document.new('&lt;person&gt;&lt;name&gt;James&lt;/name&gt;&lt;/person&gt;').root)
  =&gt; #&lt;Person:0xb78bc4a0 @name=&quot;James&quot;&gt;

  p3 = Person.load_from_xml(REXML::Document.new('&lt;person&gt;Suzy&lt;/person&gt;').root)
  =&gt; #&lt;Person:0xb78bb320 @name=&quot;Suzy&quot;&gt;

  p1.save_to_xml.write($stdout)
  &lt;person&gt;&lt;name&gt;Jim&lt;/name&gt;&lt;/person&gt;
  p2.save_to_xml.write($stdout)
  &lt;person&gt;&lt;name&gt;James&lt;/name&gt;&lt;/person&gt;
  p3.save_to_xml.write($stdout)
  &lt;person&gt;&lt;name&gt;Suzy&lt;/name&gt;&lt;/person&gt;
</pre>
<p>
Here all sub-nodes of the choice_nodes are single-attribute nodes
(text_nodes) with the same attribute (<tt>name</tt>). As you see, when
writing persons to <a href="../classes/XML.html">XML</a>, the name is
always stored in a &lt;name&gt; sub-element. Of course, this is because
that alternative appears first in the choice_node.
</p>
<h3><a name="readerswriters">Readers/Writers</a></h3>
<p>
Finally, <em>all</em> nodes support keyword arguments :reader and :writer
which allow you to extend or completely override the reading and/or writing
functionality of the node with your own code. The :reader as well as the
:writer argument must be a proc that takes as its arguments the Ruby object
to be read/written (instance of the mapping class the node belongs to) and
the <a href="../classes/XML.html">XML</a> tree to be written to/read from.
An optional third argument may be specified &#8212; it will receive a proc
that wraps the default reader/writer functionality of the node.
</p>
<p>
The :reader proc is for reading (from the <a
href="../classes/XML.html">XML</a> into the object), the :writer proc is
for writing (from the object into the <a
href="../classes/XML.html">XML</a>).
</p>
<p>
Here&#8217;s a (really contrived) example:
</p>
<pre>
  class Foo
    include XML::Mapping

    text_node :name, &quot;@name&quot;, :reader=&gt;proc{|obj,xml,default_reader|
                                         default_reader.call(obj,xml)
                                         obj.name += xml.attributes['more']
                                       },
                              :writer=&gt;proc{|obj,xml|
                                         xml.attributes['bar'] = &quot;hi #{obj.name} ho&quot;
                                       }
  end

  f = Foo.load_from_xml(REXML::Document.new('&lt;foo name=&quot;Jim&quot; more=&quot;XYZ&quot;/&gt;').root)
  =&gt; #&lt;Foo:0xb789731c @name=&quot;JimXYZ&quot;&gt;

  xml = f.save_to_xml
  xml.write $stdout,2
  &lt;foo bar='hi JimXYZ ho'/&gt;
</pre>
<p>
So there&#8217;s a &quot;Foo&quot; class with a text_node that would by
default (without the :reader and :writer proc) map the Ruby attribute
&quot;name&quot; to the <a href="../classes/XML.html">XML</a> attribute
&quot;name&quot;. The :reader proc is invoked when reading from <a
href="../classes/XML.html">XML</a> into a <tt>Foo</tt> object. The
<tt>xml</tt> argument is the <a href="../classes/XML.html">XML</a> tree,
<tt>obj</tt> is the object. <tt>default_reader</tt> is the proc that wraps
the default reading functionality of the node. We invoke it at the
beginning. For this text_node, the default reading functionality is to take
the text of the &quot;name&quot; attribute of <tt>xml</tt> and put it into
the <tt>name</tt> attribute of <tt>obj</tt>. After that, we take the text
of the &quot;more&quot; attribute of <tt>xml</tt> and append it to the
<tt>name</tt> attribute of <tt>obj</tt>. So the <a
href="../classes/XML.html">XML</a> tree <tt>&lt;foo name=&quot;Jim&quot;
more=&quot;XYZ&quot;/&gt;</tt> is converted to a <tt>Foo</tt> object with
<tt>name</tt>=&quot;JimXYZ&quot;.
</p>
<p>
In our :writer proc, we only take <tt>obj</tt> (the <tt>Foo</tt> object to
be written to <a href="../classes/XML.html">XML</a>) and <tt>xml</tt> (the
<a href="../classes/XML.html">XML</a> tree the stuff is to be written to).
Analogously to the :reader, we could take a proc that wraps the default
writing functionality of the node, but we don&#8217;t do that here&#8212;we
completely override the writing functionality with our own code, which just
takes the <tt>name</tt> attribute of the object and writes &quot;hi &lt;the
name&gt; ho&quot; to a <tt>bar</tt> <a href="../classes/XML.html">XML</a>
attribute in the <a href="../classes/XML.html">XML</a> tree (stupid
example, I know).
</p>
<p>
As a special convention, if you specify both a :reader and a :writer for a
node, and in both cases you do /not/ call the default behaviour, then you
should use the generic node type <tt>node</tt>, e.g.:
</p>
<pre>
  class SomeClass
    include XML::Mapping

    ....

    node :reader=&gt;proc{|obj,xml| ...},
         :writer=&gt;proc{|obj,xml| ...}
  end
</pre>
<p>
(since you&#8217;re completely replacing both the reading and the writing
functionality, you&#8217;re effectively replacing all the functionality of
the node, so it would be pointless and confusing to use one of the more
&quot;specific&quot; node types)
</p>
<p>
As you see, the purpose of readers and writers is to make it possible to
augment or override a node&#8217;s functionality arbitrarily, so there
shouldn&#8217;t be anything that&#8217;s absolutely impossible to achieve
with xml-mapping. However, if you use readers and writers without invoking
the default behaviour, you really do everything manually, so you&#8217;re
not doing any less work than you would do if you weren&#8217;t using
xml-mapping at all. So you&#8217;ll probably use readers and/or writers for
those bits of your mapping semantics that can&#8217;t be achieved with
xml-mapping&#8217;s predefined node types (an alternative approach might be
to override the <tt>post_load</tt> and/or <tt>post_save</tt> instance
methods on the mapping class &#8212; see the reference documentation).
</p>
<p>
An advice similar to the one given above for marshallers/unmarshallers
applies here as well: If you find yourself writing lots of readers and
writers that only differ in some easily parameterizable aspects, you should
think about defining your own node types. We talk about that <a
href="#definingnodes">below</a>, and it generally just means that you move
the (sensibly parameterized) code from your readers/writers to your node
types.
</p>
<h2><a name="mappings">Multiple Mappings per Class</a></h2>
<p>
Sometimes you might want to represent the same Ruby object in multiple
alternative ways in <a href="../classes/XML.html">XML</a>. For example, the
name of a &quot;Person&quot; object could be represented either in a
&quot;name&quot; element or a &quot;name&quot; attribute.
</p>
<p>
xml-mapping supports this by allowing you to define multiple disjoint
&quot;mappings&quot; for a mapping class. A mapping is by convention
identified with a symbol, e.g. <tt>:my_mapping</tt>,
<tt>:other_mapping</tt> etc., and each mapping comprises a root element
name and a set of node definitions. In the body of a mapping class
definition, you switch to another mapping with <tt>use_mapping
:the_mapping</tt>. All following node declarations will be added to that
mapping <b>unless</b> you specify the option :mapping=&gt;:another_mapping
for a node declaration (all node types support that option). The default
mapping (the mapping used if there was no previous <tt>use_mapping</tt> in
the class body) is named <tt>:_default</tt>.
</p>
<p>
All the worker methods like <tt>load_from_xml/file</tt>,
<tt>save_to_xml/file</tt>, <tt>load_object_from_xml/file</tt> support a
<tt>:mapping</tt> keyword argument to specify the mapping, which again
defaults to <tt>:_default</tt>.
</p>
<p>
In the following example, we define two mappings (the default one and a
mapping named <tt>:other</tt>) for <tt>Person</tt> objects with a name, an
age and an address:
</p>
<pre>
  require 'xml/mapping'

  class Address; end

  class Person
    include XML::Mapping

    # the default mapping. Stores the name and age in XML attributes,
    # and the address in a sub-element &quot;address&quot;.

    text_node :name, &quot;@name&quot;
    numeric_node :age, &quot;@age&quot;
    object_node :address, &quot;address&quot;, :class=&gt;Address

    use_mapping :other

    # the &quot;:other&quot; mapping. Non-default root element name; name and age
    # stored in XML elements; address stored in the person's element
    # itself

    root_element_name &quot;individual&quot;
    text_node :name, &quot;name&quot;
    numeric_node :age, &quot;age&quot;
    object_node :address, &quot;.&quot;, :class=&gt;Address

    # you could also specify the mapping on a per-node basis with the
    # :mapping option, e.g.:
    #
    # numeric_node :age, &quot;age&quot;, :mapping=&gt;:other
  end

  class Address
    include XML::Mapping

    # the default mapping.

    text_node :street, &quot;street&quot;
    numeric_node :number, &quot;number&quot;
    text_node :city, &quot;city&quot;
    numeric_node :zip, &quot;zip&quot;

    use_mapping :other

    # the &quot;:other&quot; mapping.

    text_node :street, &quot;street-name&quot;
    numeric_node :number, &quot;street-name/@number&quot;
    text_node :city, &quot;city-name&quot;
    numeric_node :zip, &quot;city-name/@zip-code&quot;
  end

  ## usage

  # XML representation of a person in the default mapping
  xml = REXML::Document.new('
  &lt;person name=&quot;Suzy&quot; age=&quot;28&quot;&gt;
    &lt;address&gt;
      &lt;street&gt;Abbey Road&lt;/street&gt;
      &lt;number&gt;72&lt;/number&gt;
      &lt;city&gt;London&lt;/city&gt;
      &lt;zip&gt;18827&lt;/zip&gt;
    &lt;/address&gt;
  &lt;/person&gt;').root

  # load using the default mapping
  p = Person.load_from_xml xml
  =&gt; #&lt;Person:0xb787c10c @address=#&lt;Address:0xb787b89c @city=&quot;London&quot;, @number=72, @street=&quot;Abbey Road&quot;, @zip=18827&gt;, @name=&quot;Suzy&quot;, @age=28&gt;

  # save using the default mapping
  xml2 = p.save_to_xml
  xml2.write $stdout,2
  &lt;person name='Suzy' age='28'&gt;
        &lt;address&gt;
          &lt;street&gt;Abbey Road&lt;/street&gt;
          &lt;number&gt;72&lt;/number&gt;
          &lt;city&gt;London&lt;/city&gt;
          &lt;zip&gt;18827&lt;/zip&gt;
        &lt;/address&gt;
      &lt;/person&gt;
  # xml2 identical to xml

  # now, save the same person to XML using the :other mapping...
  other_xml = p.save_to_xml :mapping=&gt;:other
  other_xml.write $stdout,2
  &lt;individual&gt;
        &lt;name&gt;Suzy&lt;/name&gt;
        &lt;age&gt;28&lt;/age&gt;
        &lt;street-name number='72'&gt;Abbey Road&lt;/street-name&gt;
        &lt;city-name zip-code='18827'&gt;London&lt;/city-name&gt;
      &lt;/individual&gt;
  # load it again using the :other mapping
  p2 = Person.load_from_xml other_xml, :mapping=&gt;:other
  =&gt; #&lt;Person:0xb7873f98 @address=#&lt;Address:0xb7873610 @city=&quot;London&quot;, @number=72, @street=&quot;Abbey Road&quot;, @zip=18827&gt;, @name=&quot;Suzy&quot;, @age=28&gt;

  # p2 identical to p
</pre>
<p>
In this example, each of the two mappings contains nodes that map the same
set of Ruby attributes (name, age and address). This is probably what you
want most of the time (since you&#8217;re normally defining multiple <a
href="../classes/XML.html">XML</a> mappings for the same Ruby data), but
it&#8217;s not a necessity at all. When a mapping class is defined,
xml-mapping will add all Ruby attributes from all mappings to it.
</p>
<p>
You may have noticed that the <tt>object_node</tt>s in the <tt>Person</tt>
class apply the mapping they were themselves defined in to their
sub-ordinated class (<tt>Address</tt>). This is the case for all <a
href="#subobjnodes">Single-attribute Nodes with Sub-objects</a>
(<tt>object_node</tt>, <tt>array_node</tt> and <tt>hash_node</tt>) unless
you explicitly specify a different mapping for the sub-object(s) using the
option :sub_mapping, e.g.
</p>
<pre>
  object_node :address, &quot;address&quot;, :class=&gt;Address, :sub_mapping=&gt;:other
</pre>
<h2><a name="definingnodes">Defining your own Node Types</a></h2>
<p>
It&#8217;s easy to write additional node types and register them with the
xml-mapping library (the following node types come with xml-mapping:
<tt>node</tt>, <tt>text_node</tt>, <tt>numeric_node</tt>,
<tt>boolean_node</tt>, <tt>object_node</tt>, <tt>array_node</tt>,
<tt>hash_node</tt>, <tt>choice_node</tt>).
</p>
<p>
I&#8217;ll first show an example, then some more theoretical insight.
</p>
<h3>Example</h3>
<p>
Let&#8217;s say we want to extend the <tt>Signature</tt> class from the
example to include the time at which the signature was created. We want the
new <a href="../classes/XML.html">XML</a> representation of such a
signature to look like this:
</p>
<pre>
  &lt;Signature&gt;
    &lt;Name&gt;John Doe&lt;/Name&gt;
    &lt;Position&gt;product manager&lt;/Position&gt;
    &lt;signed-on&gt;
      &lt;day&gt;13&lt;/day&gt;
      &lt;month&gt;2&lt;/month&gt;
      &lt;year&gt;2005&lt;/year&gt;
    &lt;/signed-on&gt;
  &lt;/Signature&gt;
</pre>
<p>
(we only save year, month and day to make this example shorter), and the
mapping class declaration to look like this:
</p>
<pre>
  class Signature
    include XML::Mapping

    text_node :name, &quot;Name&quot;
    text_node :position, &quot;Position&quot;, :default_value=&gt;&quot;Some Employee&quot;
    time_node :signed_on, &quot;signed-on&quot;, :default_value=&gt;Time.now
  end
</pre>
<p>
(i.e. a new &quot;time_node&quot; declaration was added).
</p>
<p>
We want this <tt>time_node</tt> call to define an attribute named
<tt>signed_on</tt> which holds the date value from the <a
href="../classes/XML.html">XML</a> document in an instance of class
<tt>Time</tt>.
</p>
<p>
This node type can be defined with this piece of code:
</p>
<pre>
  require 'xml/mapping/base'

  class TimeNode &lt; XML::Mapping::SingleAttributeNode
    def initialize(*args)
      path,*args = super(*args)
      @y_path = XML::XXPath.new(path+&quot;/year&quot;)
      @m_path = XML::XXPath.new(path+&quot;/month&quot;)
      @d_path = XML::XXPath.new(path+&quot;/day&quot;)
      args
    end

    def extract_attr_value(xml)
      y,m,d = default_when_xpath_err{ [@y_path.first(xml).text.to_i,
                                       @m_path.first(xml).text.to_i,
                                       @d_path.first(xml).text.to_i]
                                    }
      Time.local(y,m,d)
    end

    def set_attr_value(xml, value)
      @y_path.first(xml,:ensure_created=&gt;true).text = value.year
      @m_path.first(xml,:ensure_created=&gt;true).text = value.month
      @d_path.first(xml,:ensure_created=&gt;true).text = value.day
    end
  end

  XML::Mapping.add_node_class TimeNode
</pre>
<p>
The last line registers the new node type with the xml-mapping library. The
name of the node factory method (&quot;time_node&quot;) is automatically
derived from the class name of the node type (&quot;TimeNode&quot;).
</p>
<p>
There will be one instance of the node type <tt>TimeNode</tt> per
<tt>time_node</tt> declaration per mapping class (not per mapping class
instance). That instance (the &quot;node&quot; for short) will be created
by the node factory method (<tt>time_node</tt>); there&#8217;s no need to
instantiate the node type directly. The <tt>time_node</tt> method places
the node into the mapping class; the @owner attribute of the node is set to
reference the mapping class. The node factory method passes the mapping
class the node appears in (<tt>Signature</tt>), followed by its own
arguments, to the node&#8217;s constructor. In the example, the
<tt>time_node</tt> method calls <tt>TimeNode.new(Signature, :signed_on,
&quot;signed-on&quot;, :default_value=&gt;Time.now)</tt>). <tt>new</tt> of
course creates the node and then delegates the arguments to our initializer
<tt>initialize</tt>. We first call the superclass&#8217;s initializer,
which strips off from the argument list those arguments it handles itself,
and returns the remaining ones. In this case, the superclass <a
href="../classes/XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>
handles the <tt>Signature</tt>, <tt>:signed_on</tt> and
<tt>:default_value=&gt;Time.now</tt> arguments &#8212; <tt>Signature</tt>
is stored into <tt>@owner</tt>, <tt>:signed_on</tt> is stored into
<tt>@attrname</tt>, and <tt>{:default_value=&gt;Time.now}</tt> is stored
into <tt>@options</tt>. The remaining argument list
<tt>[&quot;signed-on&quot;]</tt> is returned; we capture the
<tt>&quot;signed-on&quot;</tt> string in <em>path</em> (the rest of the
argument list (an empty array) we capture in <em>args</em> for returning it
at the end of the initializer. This isn&#8217;t strictly necessary,
it&#8217;s just a convention that a node class initializer should always
return those arguments it didn&#8217;t handle itself). We&#8216;ll
interpret <em>path</em> as an XPath expression that locates the time value
relative to the parent mapping object&#8217;s <a
href="../classes/XML.html">XML</a> tree (in this case, this would be the <a
href="../classes/XML.html">XML</a> tree rooted at the
<tt>&lt;Signature&gt;</tt> element, i.e. the tree the <tt>Signature</tt>
instance was read from). We&#8216;ll later have to read/store the year,
month, and day values from <tt>path+&quot;/year&quot;</tt>,
<tt>path+&quot;/month&quot;</tt>, and <tt>path+&quot;/day&quot;</tt>,
respectively, so we create (and precompile) three corresponding XPath
expressions using <a
href="../classes/XML/XXPath.html#M000061">XML::XXPath.new</a> and store
them into member variables of the node. <a
href="../classes/XML/XXPath.html">XML::XXPath</a> is an XPath
implementation that is bundled with xml-mapping. It is very incomplete, but
it supports writing (not just reading) of <a
href="../classes/XML.html">XML</a> nodes, which is needed to support
writing data back to <a href="../classes/XML.html">XML</a>. The <a
href="../classes/XML/XXPath.html">XML::XXPath</a> library is explained in
more detail <a href="#xpath">below</a>.
</p>
<p>
The <tt>extract_attr_value</tt> method is called whenever an instance of
the mapping class the node belongs to (<tt>Signature</tt> in the example)
is being created from an <a href="../classes/XML.html">XML</a> tree. The
parameter <em>xml</em> is that tree (again, this is the tree rooted at the
<tt>&lt;Signature&gt;</tt> element in this example). The method
implementation is expected to extract the single attribute&#8217;s value
from <em>xml</em> and return it, or raise <a
href="../classes/XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
if the attribute was &quot;unset&quot; in the <a
href="../classes/XML.html">XML</a> (this exception tells the framework that
the default value should be put in place if it was defined), or raise any
other exception to signal an error and abort the whole process. Our
superclass <a
href="../classes/XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>
will store the returned single attribute&#8217;s value into the
<tt>signed_on</tt> attribute of the <tt>Signature</tt> instance being read
in. In our implementation, we apply the xpath expressions created during
initialization to <em>xml</em> (e.g. <tt>@y_path.first(xml)</tt>). An
expression <em>xpath_expr</em>.first(<em>xml</em>) returns (as a <a
href="../classes/REXML.html">REXML</a> element) the first sub-element of
<em>xml</em> that matches <em>xpath_expr</em>, or raises <a
href="../classes/XML/XXPathError.html">XML::XXPathError</a> if there was no
such element. We apply <a href="../classes/REXML.html">REXML</a>&#8217;s
<em>text</em> method to the returned element to get out the element&#8217;s
text, convert it to integer, and supply it to the constructor of the
<tt>Time</tt> object to be returned. As a side note, if an XPath expression
matches <a href="../classes/XML.html">XML</a> attributes, <a
href="../classes/XML/XXPath.html">XML::XXPath</a> methods like
<em>first</em> will return <a
href="../classes/XML/XXPath/Accessors/Attribute.html">XML::XXPath::Accessors::Attribute</a>
nodes that behave similarly to REXML::Element nodes, including support for
messages like <em>name</em> and <em>text</em>, so this would&#8217;ve
worked also if our XPath expressions had referred to <a
href="../classes/XML.html">XML</a> attributes, not elements. The
<tt>default_when_xpath_err</tt> thing calls the supplied block and returns
its value, but maps the exception <a
href="../classes/XML/XXPathError.html">XML::XXPathError</a> to the
mentioned <a
href="../classes/XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
(any other exceptions fall through unchanged). As said above, <a
href="../classes/XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
is caught by the framework (more precisely, by our superclass <a
href="../classes/XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>),
and the default value is set if it was provided. So you should just wrap
<tt>default_when_xpath_err</tt> around any applications of XPath
expressions whose non-presence in the <a href="../classes/XML.html">XML</a>
you want to be considered a non-presence of the attribute you&#8217;re
trying to extract. (<a href="../classes/XML/XXPath.html">XML::XXPath</a> is
designed to know knothing about <a
href="../classes/XML/Mapping.html">XML::Mapping</a>, so it doesn&#8217;t
raise <a
href="../classes/XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
directly)
</p>
<p>
The <tt>set_attr_value</tt> method is called whenever an instance of the
mapping class the node belongs to (<tt>Signature</tt> in the example) is
being stored into an <a href="../classes/XML.html">XML</a> tree. The
<em>xml</em> parameter is the <a href="../classes/XML.html">XML</a> tree (a
<a href="../classes/REXML.html">REXML</a> element node; here this is again
the tree rooted at the <tt>&lt;Signature&gt;</tt> element); <em>value</em>
is the current value of the single attribute (in this example, the
<tt>signed_on</tt> attribute of the <tt>Signature</tt> instance being
stored). <em>xml</em> will most probably be &quot;half-populated&quot; by
the time this method is called &#8212; the framework calls the
<tt>set_attr_value</tt> methods of all nodes of a mapping class in the
order of their definition, letting each node fill its &quot;bit&quot; into
<em>xml</em>. The method implementation is expected to write <em>value</em>
into (the correct sub-elements of) <em>xml</em>, or raise an exception to
signal an error and abort the whole process. No default value handling is
done here; <tt>set_attr_value</tt> won&#8217;t be called at all if the
attribute had been set to its default value. In our implementation we grab
the year, month and day values from <em>value</em> (which must be a
<tt>Time</tt>), and store it into the sub-elements of <em>xml</em>
identified by XPath expressions <tt>@y_path</tt>, <tt>@m_path</tt> and
<tt>@d_path</tt>, respectively. We do this by calling <a
href="../classes/XML/XXPath.html#M000063">XML::XXPath#first</a> with an
additional parameter <tt>:ensure_created=&gt;true</tt>. An expression
<em>xpath_expr</em>.first(<em>xml</em>,:ensure_created=&gt;true) works just
like <em>xpath_expr</em>.first(<em>xml</em>) if <em>xpath_expr</em> was
already present in <em>xml</em>. If it was not, it is created (preferably
at the end of <em>xml</em>&#8217;s list of sub-nodes), and returned. See <a
href="#xpath">below</a> for a more detailed documentation of the XPath
interpreter.
</p>
<h3>Element order in created <a href="../classes/XML.html">XML</a> documents</h3>
<p>
As just said, <a href="../classes/XML/XXPath.html">XML::XXPath</a>, when
used to create new <a href="../classes/XML.html">XML</a> nodes, generally
appends those nodes to the end of the list of subnodes of the node the
xpath expression was applied to. All xml-mapping nodes that come with
xml-mapping use <a href="../classes/XML/XXPath.html">XML::XXPath</a> when
writing data to <a href="../classes/XML.html">XML</a>, and therefore also
append their data to the <a href="../classes/XML.html">XML</a> data written
by preceding nodes (the nodes are invoked in the order of their
definition). This means that, generally, your output data will appear in
the <a href="../classes/XML.html">XML</a> document in the same order in
which the corresponding xml-mapping node definitions appeared in the
mapping class (unless you used XPath expressions like foo[number] which
explicitly dictate a fixed position in the sequence of <a
href="../classes/XML.html">XML</a> nodes). For instance, in the
<tt>Order</tt> class from the example at the beginning of this document, if
we put the <tt>:signatures</tt> node <em>before</em> the <tt>:items</tt>
node, the <tt>&lt;Signed-By&gt;</tt> element will appear <em>before</em>
the sequence of <tt>&lt;Item&gt;</tt> elements in the output <a
href="../classes/XML.html">XML</a>.
</p>
<p>
The following is a more systematic overview of the basic node types. The
description is self-contained, so some information from the previous
section will be repeated.
</p>
<h3>Node Types Are Ruby Classes</h3>
<p>
A node type is implemented as a Ruby class derived from <a
href="../classes/XML/Mapping/Node.html">XML::Mapping::Node</a> or one of
its subclasses.
</p>
<p>
The following node types (node classes) come with xml-mapping (they all
live in the <a href="../classes/XML/Mapping.html">XML::Mapping</a>
namespace, which I&#8217;ve left out here for brevity):
</p>
<pre>
  Node
   +-SingleAttributeNode
   |  +-SubObjectBaseNode
   |  |  +-ObjectNode
   |  |  +-ArrayNode
   |  |  +-HashNode
   |  +-TextNode
   |  +-NumericNode
   |  +-BooleanNode
   +-ChoiceNode
</pre>
<p>
<a href="../classes/XML/Mapping/Node.html">XML::Mapping::Node</a> is the
base class for all nodes, <a
href="../classes/XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>
is the base class for <a href="#sanodes">single-attribute nodes</a>, and <a
href="../classes/XML/Mapping/SubObjectBaseNode.html">XML::Mapping::SubObjectBaseNode</a>
is the base class for <a href="#subobjnodes">single-attribute nodes with
sub-objects</a>. <a
href="../classes/XML/Mapping/TextNode.html">XML::Mapping::TextNode</a>, <a
href="../classes/XML/Mapping/ArrayNode.html">XML::Mapping::ArrayNode</a>
etc. are of course the <tt>text_node</tt>, <tt>array_node</tt> etc.
we&#8217;ve talked about in this document. When you&#8217;ve written a new
node class, you register it with xml-mapping by calling <tt><a
href="../classes/XML/Mapping.html#M000026">XML::Mapping.add_node_class</a>
MyNode</tt>. When you do that, xml-mapping automatically defines the node
factory method for your class &#8212; the method&#8217;s name (e.g.
<tt>my_node</tt>) is derived from the node&#8217;s class name (e.g.
Foo::Bar::MyNode) by stripping all parent module names, and then converting
capital letters to lowercase and preceding them with an underscore. In
fact, this is just how all the predefined node types are defined &#8212;
those node types are not &quot;special&quot;; they&#8217;re defined in the
source file +xml/mapping/standard_nodes.rb+ and then registered normally in
+xml/mapping.rb+. The source code of the built-in nodes is not very long or
complicated; you may consider reading it in addition to this text to gain a
better understanding.
</p>
<h3>How Node Types Work</h3>
<p>
The xml-mapping core &quot;operates&quot; node types as follows:
</p>
<h4>Node Initialization</h4>
<p>
As said above, when a node class is registered with xml-mapping by calling
<tt><a
href="../classes/XML/Mapping.html#M000026">XML::Mapping.add_node_class</a>
TheNodeClass</tt>, xml-mapping automatically generates the node factory
method for that type. The node factory method will effectively be defined
as a class method of the <a
href="../classes/XML/Mapping.html">XML::Mapping</a> module, which is why
one can call it from the body of a mapping class definition. The generated
method will create a new instance of the node class (a <b>node</b> for
short) by calling <em>new</em> on the node class. The list of parameters to
<em>new</em> will consist of <em>the mapping class, followed by all
arguments that were passed to the node factory method</em>. For example,
when you have this node declaration:
</p>
<pre>
  class MyMappingClass
    include XML::Mapping

    my_node :foo, &quot;bar&quot;, 42, :hi=&gt;&quot;ho&quot;
  end
</pre>
<p>
, then the node factory method (<tt>my_node</tt>) calls
<tt>MyNode.new(MyMappingClass, :foo, &quot;bar&quot;, 42,
:hi=&gt;&quot;ho&quot;)</tt>.
</p>
<p>
<em>new</em> of course creates the instance and calls <em>initialize</em>
on it. The <em>initialize</em> implementation will generally store the
parameters into some instance variables for later usage. As a convention,
<em>initialize</em> should always extract from the parameter list those
parameters it processes itself, process them, and return an array
containing the remaining (still unprocessed) parameters. Thus, an
implementation of <em>initialize</em> follows this pattern:
</p>
<pre>
  def initialize(*args)
    myparam1,myparam2,...,myparamx,*args = super(*args)

    .... process the myparam1,myparam2,...,myparamx ....

    # return still unprocessed args
    args
  end
</pre>
<p>
(since the called superclass initializer is written the same way, the
parameter array returned by it will already be stripped of all parameters
that the superclass initializer (or any of its superclasses&#8217;s
initializers) processed)
</p>
<p>
This technique is a simple way to &quot;chain&quot; the initializers of all
superclasses of a node class, starting with the topmost one (Node), so that
each initializer can easily find out and process the parameters it is
responsible for.
</p>
<p>
The base node class <a
href="../classes/XML/Mapping/Node.html">XML::Mapping::Node</a> provides an
<em>initialize</em> implementation that, among other things (described
below), adds <em>self</em> (i.e. the created node) to the internal list of
nodes held by the mapping class, and sets the @owner attribute of
<em>self</em> to reference the mapping class.
</p>
<p>
So, effectively there will be one instance of a node class (a node) per
node definition, and that instance lives in the mapping class the node was
defined in.
</p>
<h4>Node Operation during Marshalling and Unmarshalling</h4>
<p>
When an instance of a mapping class is created or filled from an <a
href="../classes/XML.html">XML</a> tree, xml-mapping will call
<tt>xml_to_obj</tt> on all nodes defined in that mapping class in the <a
href="#mappings">mapping</a> the node is defined in, in the order of their
definition. Two parameters will be passed: the mapping class instance being
created/filled, and the <a href="../classes/XML.html">XML</a> tree the
instance is being created/filled from. The implementation of
<tt>xml_to_obj</tt> is expected to read whatever pieces of data it is
responsible for from the <a href="../classes/XML.html">XML</a> tree and put
it into the appropriate variables/attributes etc. of the instance.
</p>
<p>
When an instance of a mapping class is stored or filled into an <a
href="../classes/XML.html">XML</a> tree, xml-mapping will call
<tt>obj_to_xml</tt> on all nodes defined in that mapping class in the <a
href="#mappings">mapping</a> the node is defined in, in the order of their
definition, again passing as parameters the mapping class instance being
stored, and the <a href="../classes/XML.html">XML</a> tree the instance is
being stored/filled into. The implementation of <tt>obj_to_xml</tt> is
expected to read whatever pieces of data it is responsible for from the
instance and put it into the appropriate <a
href="../classes/XML.html">XML</a> elements/XML attr etc. of the <a
href="../classes/XML.html">XML</a> tree.
</p>
<h3>Basic Node Types Overview</h3>
<p>
The following is an overview of how initialization and
marshalling/unmarshalling is implemented in the node base classes (Node,
SingleAttributeNode, and SubObjectBaseNode).
</p>
<p>
TODO: summary table: member var name; introduced in class; meaning
</p>
<h4>Node</h4>
<p>
In <em>initialize</em>, the mapping class and the option arguments are
stripped from the argument list. The mapping class is stored in @owner, the
option arguments are stored (as a hash) in @options (the hash will be empty
if no options were given). The <a href="#mappings">mapping</a> the node is
defined in is determined (:mapping option, last <tt>use_mapping</tt> or
<tt>:_default</tt>) and stored in @mapping. The node then stores itself in
the list of nodes of the mapping class belonging to the mapping
(<tt>@owner.xml_mapping_nodes(:mapping=&gt;@mapping)</tt>; see <a
href="../classes/XML/Mapping/ClassMethods.html#M000032">XML::Mapping::ClassMethods#xml_mapping_nodes</a>).
This list is the list of nodes later used when marshalling/unmarshalling an
instance of the mapping class with respect to a given mapping. This means
that node implementors will not normally &quot;see&quot; anything of the
mapping (they don&#8217;t need to access the @mapping variable) because the
marshalling/unmarshalling methods (<tt>obj_to_xml</tt>/<tt>xml_to_obj</tt>)
simply won&#8217;t be called if the node&#8217;s mapping is not the same as
the mapping the marshalling/unmarshalling is happening with.
</p>
<p>
Furthermore, if :reader and/or :writer options were given,
<tt>xml_to_obj</tt> resp. <tt>obj_to_xml</tt> are transparently overwritten
on the node to delegate to the supplied :reader/:writer procs.
</p>
<p>
The marshalling/unmarshalling methods
(<tt>obj_to_xml</tt>/<tt>xml_to_obj</tt>) are not implemented in
<tt>Node</tt> (they just raise an exception).
</p>
<h4>SingleAttributeNode</h4>
<p>
In <em>initialize</em>, the attribute name is stripped from the argument
list and stored in @attrname, and an attribute of that name is added to the
mapping class the node belongs to.
</p>
<p>
During marshalling/unmarshalling of an object to/from <a
href="../classes/XML.html">XML</a>, single-attribute nodes only read/write
a single piece of the object&#8217;s state: the single attribute
(@attrname) the node handles. Because of this, the
<tt>obj_to_xml</tt>/<tt>xml_to_obj</tt> implementations in
SingleAttributeNode call two new methods introduced by SingleAttributeNode,
which must be overwritten by subclasses:
</p>
<pre>
  extract_attr_value(xml)

  set_attr_value(xml, value)
</pre>
<p>
<tt>extract_attr_value(xml)</tt> is called by <tt>xml_to_obj</tt> during
unmarshalling. <em>xml</em> is the <a href="../classes/XML.html">XML</a>
tree being read. The method must read the attribute&#8217;s value from
<em>xml</em> and return it. <tt>xml_to_obj</tt> will set the attribute to
that value.
</p>
<p>
<tt>set_attr_value(xml, value)</tt> is called by <tt>obj_to_xml</tt> during
marshalling. <em>xml</em> is the <a href="../classes/XML.html">XML</a> tree
being written, <em>value</em> is the current value of the attribute. The
method must write <em>value</em> into (the correct sub-elements/attributes)
of <em>xml</em>.
</p>
<p>
SingleAttributeNode also handles the default value, if it was specified
(via the :default_value option): When writing data to <a
href="../classes/XML.html">XML</a>, <tt>set_attr_value(xml, value)</tt>
won&#8217;t be called if the attribute was set to the default value. When
reading data from <a href="../classes/XML.html">XML</a>, the
<tt>extract_attr_value(xml)</tt> implementation must raise a special
exception, <a
href="../classes/XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>,
if it wants to indicate that the data was not present in the <a
href="../classes/XML.html">XML</a>. SingleAttributeNode will catch this
exception and put the default value, if it was defined, into the attribute.
</p>
<h4>SubObjectBaseNode</h4>
<p>
The initializer will set up additional member variables @sub_mapping,
@marshaller, and @unmarshaller.
</p>
<p>
@sub_mapping contains the mapping to be used when reading/writing the
sub-objects (either specified with :sub_mapping, or, by default, the
mapping the node itself was defined in).
</p>
<p>
@marshaller and @unmarshaller contain procs that encapsulate
writing/reading of sub-objects to/from <a
href="../classes/XML.html">XML</a>, as specified by the user with
:class/:marshaller/:unmarshaller etc. options (the meaning of those
different options was described <a href="#subobjnodes">above</a>). The
procs are there to be called from <tt>extract_attr_value</tt> or
<tt>set_attr_value</tt> whenever the need arises.
</p>
<h2><a name="xpath">XPath Interpreter</a></h2>
<p>
<a href="../classes/XML/XXPath.html">XML::XXPath</a> is an XPath parser. It
is used in xml-mapping node type definitions, but can just as well be
utilized stand-alone (it does not depend on xml-mapping). <a
href="../classes/XML/XXPath.html">XML::XXPath</a> is very incomplete and
probably will always be, but it should be reasonably efficient (XPath
expressions are precompiled), and, most importantly, it supports write
access, which is needed for writing objects to <a
href="../classes/XML.html">XML</a>. For example, if you create the path
&quot;/foo/bar[3]/baz[@key=&#8217;hiho&#8217;]&quot; in the <a
href="../classes/XML.html">XML</a> document
</p>
<pre>
  &lt;foo&gt;
    &lt;bar&gt;
      &lt;baz key=&quot;ab&quot;&gt;hello&lt;/baz&gt;
      &lt;baz key=&quot;xy&quot;&gt;goodbye&lt;/baz&gt;
    &lt;/bar&gt;
  &lt;/foo&gt;
</pre>
<p>
, you&#8217;ll get:
</p>
<pre>
  &lt;foo&gt;
    &lt;bar&gt;
      &lt;baz key='ab'&gt;hello&lt;/baz&gt;
      &lt;baz key='xy'&gt;goodbye&lt;/baz&gt;
    &lt;/bar&gt;
    &lt;bar/&gt;
    &lt;bar&gt;
      &lt;baz key='hiho'/&gt;
    &lt;/bar&gt;
  &lt;/foo&gt;
</pre>
<p>
<a href="../classes/XML/XXPath.html">XML::XXPath</a> is explained in more
detail in the reference documentation and the README_XPATH file.
</p>
<h2>License</h2>
<p>
Ruby&#8217;s.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>
