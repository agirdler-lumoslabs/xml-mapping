<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README_XPATH</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README_XPATH</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README_XPATH
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Aug 08 01:33:46 CEST 2006</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1><a href="../classes/XML.html">XML</a>-XXPATH</h1>
<h2>Overview, Motivation</h2>
<p>
Xml-xxpath is an (incomplete) XPath interpreter that is at the moment
bundled with xml-mapping. It is built on top of <a
href="../classes/REXML.html">REXML</a>. xml-mapping uses xml-xxpath
extensively for implementing its node types &#8212; see the README file and
the reference documentation (and the source code) for details. xml-xxpath,
however, does not depend on xml-mapping at all, and is useful in its own
right &#8212; maybe I&#8217;ll later distribute it as a seperate library
instead of bundling it. For the time being, if you want to use this XPath
implementation stand-alone, you can just rip the files
<tt>lib/xml/xxpath.rb</tt>, <tt>lib/xml/xxpath/steps.rb</tt>, and
<tt>lib/xml/xxpath_methods.rb</tt> out of the xml-mapping distribution and
use them on their own (they do not depend on anything else).
</p>
<p>
xml-xxpath&#8217;s XPath support is vastly incomplete (see below), but, in
addition to the normal reading/matching functionality found in other XPath
implementations (i.e. &quot;find all elements in a given <a
href="../classes/XML.html">XML</a> document matching a given XPath
expression&quot;), xml-xxpath supports <em>write access</em>. For example,
when writing the XPath expression
&quot;/foo/bar[3]/baz[@key=&#8217;hiho&#8217;]&quot; to the <a
href="../classes/XML.html">XML</a> document
</p>
<pre>
  &lt;foo&gt;
    &lt;bar&gt;
      &lt;baz key='ab'&gt;hello&lt;/baz&gt;
      &lt;baz key='xy'&gt;goodbye&lt;/baz&gt;
    &lt;/bar&gt;
  &lt;/foo&gt;
</pre>
<p>
, you&#8217;ll get:
</p>
<pre>
  &lt;foo&gt;
    &lt;bar&gt;
      &lt;baz key='ab'&gt;hello&lt;/baz&gt;
      &lt;baz key='xy'&gt;goodbye&lt;/baz&gt;
    &lt;/bar&gt;
    &lt;bar/&gt;
    &lt;bar&gt;&lt;baz key='hiho'/&gt;&lt;/bar&gt;
  &lt;/foo&gt;
</pre>
<p>
This feature is used by xml-mapping when writing (marshalling) Ruby objects
to <a href="../classes/XML.html">XML</a>, and is actually the reason why I
couldn&#8217;t just use any of the existing XPath implementations, e.g. the
one that comes with <a href="../classes/REXML.html">REXML</a>. Also, the
whole xml-xxpath implementation is just 300 lines of Ruby code, it is quite
fast (paths are precompiled), and xml-xxpath returns matched elements in
the order they appeared in the source document &#8212; I&#8217;ve heard
REXML::XPath doesn&#8217;t do that :)
</p>
<p>
Some basic knowledge of XPath is helpful for reading this document (I
don&#8217;t know very much either).
</p>
<p>
At the moment, xml-xxpath understands XPath expressions of the form
[<tt>/</tt>]<em>pathelement</em><tt>/[/]</tt><em>pathelement</em><tt>/[/]</tt>&#8230;,
where each <em>pathelement</em> must be one of these:
</p>
<ul>
<li>a simple element name <em>name</em>, e.g. <tt>signature</tt>

</li>
<li>an attribute name, @<em>attr_name</em>, e.g. <tt>@key</tt>

</li>
<li>a combination of an element name and an attribute name and -value, in the
form
<em>elt_name</em>[@<em>attr_name</em>=&#8217;<em>attr_value</em>&#8217;]

</li>
<li>an element name and an index, <em>elt_name</em>[<em>index</em>]

</li>
<li>the &quot;match-all&quot; path element, <tt>*</tt>

</li>
</ul>
<h2>Usage</h2>
<p>
Xml-xxpath defines the class <a
href="../classes/XML/XXPath.html">XML::XXPath</a>. An instance of that
class wraps an XPath expression, the string representation of which must be
supplied when constructing the instance. You then call instance methods
like <em>first</em>, <em>all</em> or <em>create_new</em> on the instance,
supplying the <a href="../classes/REXML.html">REXML</a> Element the XPath
expression should be applied to, and get the results, or, in the case of
write access, the element is updated in-place.
</p>
<h3>Read Access</h3>
<pre>
  require 'xml/xxpath'

  d=REXML::Document.new &lt;&lt;EOS
    &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key=&quot;work&quot;&gt;Java&lt;/baz&gt;
        &lt;baz key=&quot;play&quot;&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
      &lt;bar&gt;
        &lt;baz key=&quot;ab&quot;&gt;hello&lt;/baz&gt;
        &lt;baz key=&quot;play&quot;&gt;scrabble&lt;/baz&gt;
        &lt;baz key=&quot;xy&quot;&gt;goodbye&lt;/baz&gt;
      &lt;/bar&gt;
      &lt;more&gt;
        &lt;baz key=&quot;play&quot;&gt;poker&lt;/baz&gt;
      &lt;/more&gt;
    &lt;/foo&gt;
  EOS

  ###read access
  path=XML::XXPath.new(&quot;/foo/bar[2]/baz&quot;)

  # path.all(document) gives all elements matching path in document
  path.all(d)
  =&gt; [&lt;baz key='ab'&gt; ... &lt;/&gt;, &lt;baz key='play'&gt; ... &lt;/&gt;, &lt;baz key='xy'&gt; ... &lt;/&gt;]

  # loop over them
  path.each(d){|elt| puts elt.text}
  hello
  scrabble
  goodbye
  =&gt; [&lt;baz key='ab'&gt; ... &lt;/&gt;, &lt;baz key='play'&gt; ... &lt;/&gt;, &lt;baz key='xy'&gt; ... &lt;/&gt;]

  # the first of those
  path.first(d)
  =&gt; &lt;baz key='ab'&gt; ... &lt;/&gt;

  # no match here (only three &quot;baz&quot; elements)
  path2=XML::XXPath.new(&quot;/foo/bar[2]/baz[4]&quot;)
  path2.all(d)
  =&gt; []

  # &quot;first&quot; raises XML::XXPathError in such cases...
  path2.first(d)
  XML::XXPathError: path not found: /foo/bar[2]/baz[4]
        from ../lib/xml/xxpath.rb:75:in `first'

  #...unless we allow nil returns
  path2.first(d,:allow_nil=&gt;true)
  =&gt; nil

  #attribute nodes can also be returned
  keysPath=XML::XXPath.new(&quot;/foo/*/*/@key&quot;)

  keysPath.all(d).map{|attr|attr.text}
  =&gt; [&quot;work&quot;, &quot;play&quot;, &quot;ab&quot;, &quot;play&quot;, &quot;xy&quot;, &quot;play&quot;]
</pre>
<p>
The objects supplied to the <tt>all()</tt>, <tt>first()</tt>, and
<tt>each()</tt> calls must be <a href="../classes/REXML.html">REXML</a>
element nodes, i.e. they must support messages like <tt>elements</tt>,
<tt>attributes</tt> etc (instances of REXML::Element and its subclasses do
this). The calls return the found elements as instances of REXML::Element
or <a
href="../classes/XML/XXPath/Accessors/Attribute.html">XML::XXPath::Accessors::Attribute</a>.
The latter is a wrapper around attribute nodes that is largely
call-compatible to REXML::Element. This is so you can write things like
<tt>path.each{|node|puts node.text}</tt> without having to special-case
anything even if the path matches attributes, not just elements.
</p>
<p>
As you can see, you can re-use path objects, applying them to different <a
href="../classes/XML.html">XML</a> elements at will. You should do this
because the XPath pattern is stored inside the XPath object in a
pre-compiled form, which makes it more efficient.
</p>
<p>
The path elements of the XPath pattern are applied to the
<tt>.elements</tt> collection of the passed <a
href="../classes/XML.html">XML</a> element and its sub-elements, starting
with the first one. This is shown by the following code:
</p>
<pre>
  require 'xml/xxpath'

  d=REXML::Document.new &lt;&lt;EOS
    &lt;foo&gt;
      &lt;bar x=&quot;hello&quot;&gt;
        &lt;first&gt;
          &lt;second&gt;pingpong&lt;/second&gt;
        &lt;/first&gt;
      &lt;/bar&gt;
      &lt;bar x=&quot;goodbye&quot;/&gt;
    &lt;/foo&gt;
  EOS

  XML::XXPath.new(&quot;/foo/bar&quot;).all(d)
  =&gt; [&lt;bar x='hello'&gt; ... &lt;/&gt;, &lt;bar x='goodbye'/&gt;]

  XML::XXPath.new(&quot;/bar&quot;).all(d)
  =&gt; []

  XML::XXPath.new(&quot;/foo/bar&quot;).all(d.root)
  =&gt; []

  XML::XXPath.new(&quot;/bar&quot;).all(d.root)
  =&gt; [&lt;bar x='hello'&gt; ... &lt;/&gt;, &lt;bar x='goodbye'/&gt;]

  firstelt = XML::XXPath.new(&quot;/foo/bar/first&quot;).first(d)
  =&gt; &lt;first&gt; ... &lt;/&gt;

  XML::XXPath.new(&quot;/first/second&quot;).all(firstelt)
  =&gt; []

  XML::XXPath.new(&quot;/second&quot;).all(firstelt)
  =&gt; [&lt;second&gt; ... &lt;/&gt;]
</pre>
<p>
A <a href="../classes/REXML.html">REXML</a> <tt>Document</tt> object is a
<a href="../classes/REXML.html">REXML</a> <tt>Element</tt> object whose
<tt>elements</tt> collection consists only of a single member &#8212; the
document&#8217;s root node. The first path element of the XPath &#8212;
&quot;foo&quot; in the example &#8212; is matched against that. That is why
the path &quot;/bar&quot; in the example doesn&#8217;t match anything when
matched against the document <tt>d</tt> itself.
</p>
<p>
An ordinary <a href="../classes/REXML.html">REXML</a> <tt>Element</tt>
object that represents a node somewhere inside an <a
href="../classes/XML.html">XML</a> tree has an <tt>elements</tt> collection
that consists of all the element&#8217;s direct sub-elements. That is why
XPath patterns matched against the <tt>firstelt</tt> element in the example
*must not* start with &quot;/first&quot; (unless there is a child node that
is also named &quot;first&quot;).
</p>
<h3>Write Access</h3>
<p>
You may pass an <tt>:ensure_created=&gt;true</tt> option argument to
<em>path</em>.first(<em>elt</em>)/<em>path</em>.all(<em>elt</em>) calls to
make sure that <em>path</em> exists inside the passed <a
href="../classes/XML.html">XML</a> element <em>elt</em>. If it existed
before, nothing changes, and the call behaves just as it would without the
option argument. If the path didn&#8217;t exist before, the <a
href="../classes/XML.html">XML</a> element is modified such that
</p>
<ul>
<li>the path exists afterwards

</li>
<li>all paths that existed before still exist afterwards

</li>
<li>the modification is as small as possible (i.e. as few elements as possible
are added, additional attributes are added to existing elements if possible
etc.)

</li>
</ul>
<p>
The created resp. previously existing, matching elements are returned.
</p>
<p>
Examples:
</p>
<pre>
  require 'xml/xxpath'

  d=REXML::Document.new &lt;&lt;EOS
    &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key=&quot;work&quot;&gt;Java&lt;/baz&gt;
        &lt;baz key=&quot;play&quot;&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;/foo&gt;
  EOS

  rootelt=d.root

  ### ensuring that a specific path exists inside the document

  XML::XXPath.new(&quot;/bar/baz[@key='work']&quot;).first(rootelt,:ensure_created=&gt;true)
  =&gt; &lt;baz key='work'&gt; ... &lt;/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;/foo&gt;

  ## no change (path existed before)

  XML::XXPath.new(&quot;/bar/baz[@key='42']&quot;).first(rootelt,:ensure_created=&gt;true)
  =&gt; &lt;baz key='42'/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;baz key='42'/&gt;
        &lt;/bar&gt;
    &lt;/foo&gt;

  ## path was added

  XML::XXPath.new(&quot;/bar/baz[@key='42']&quot;).first(rootelt,:ensure_created=&gt;true)
  =&gt; &lt;baz key='42'/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;baz key='42'/&gt;
        &lt;/bar&gt;
    &lt;/foo&gt;

  ## no change this time

  XML::XXPath.new(&quot;/bar/baz[@key2='hello']&quot;).first(rootelt,:ensure_created=&gt;true)
  =&gt; &lt;baz key2='hello' key='work'&gt; ... &lt;/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='hello' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;baz key='42'/&gt;
        &lt;/bar&gt;
    &lt;/foo&gt;

  ## this fit in the 1st &quot;baz&quot; element since
  ## there was no &quot;key2&quot; attribute there before.

  XML::XXPath.new(&quot;/bar/baz[2]&quot;).first(rootelt,:ensure_created=&gt;true)
  =&gt; &lt;baz key='play'&gt; ... &lt;/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='hello' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;baz key='42'/&gt;
        &lt;/bar&gt;
    &lt;/foo&gt;

  ## no change

  XML::XXPath.new(&quot;/bar/baz[6]/@haha&quot;).first(rootelt,:ensure_created=&gt;true)
  =&gt; #&lt;XML::XXPath::Accessors::Attribute:0xb794b178 @name=&quot;haha&quot;, @parent=&lt;baz haha='[unset]'/&gt;&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='hello' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;baz key='42'/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz haha='[unset]'/&gt;
        &lt;/bar&gt;
    &lt;/foo&gt;

  ## for there to be a 6th &quot;baz&quot; element, there must be 1st..5th &quot;baz&quot; elements

  XML::XXPath.new(&quot;/bar/baz[6]/@haha&quot;).first(rootelt,:ensure_created=&gt;true)
  =&gt; #&lt;XML::XXPath::Accessors::Attribute:0xb7942708 @name=&quot;haha&quot;, @parent=&lt;baz haha='[unset]'/&gt;&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='hello' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;baz key='42'/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz haha='[unset]'/&gt;
        &lt;/bar&gt;
    &lt;/foo&gt;

  ## no change this time
</pre>
<p>
Alternatively, you may pass a <tt>:create_new=&gt;true</tt> option argument
or call <tt>create_new</tt> (<em>path</em>.create_new(<em>elt</em>) is
equivalent to <em>path</em>.first(<em>elt</em>,:create_new=&gt;true)). In
that case, a new node is created in <em>elt</em> for each path element of
<em>path</em> (or an exception raised if that wasn&#8217;t possible for any
path element).
</p>
<p>
Examples:
</p>
<pre>
  require 'xml/xxpath'

  d=REXML::Document.new &lt;&lt;EOS
    &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key=&quot;work&quot;&gt;Java&lt;/baz&gt;
        &lt;baz key=&quot;play&quot;&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;/foo&gt;
  EOS

  rootelt=d.root

  path1=XML::XXPath.new(&quot;/bar/baz[@key='work']&quot;)

  path1.create_new(rootelt)
  =&gt; &lt;baz key='work'/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
      &lt;/foo&gt;

  ## a new element is created for *each* path element, regardless of
  ## what existed before. So a new &quot;bar&quot; element was added, with a new
  ## &quot;baz&quot; element inside it

  ## same call again...
  path1.create_new(rootelt)
  =&gt; &lt;baz key='work'/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
      &lt;/foo&gt;

  ## same procedure -- new elements added for each path element

  # get reference to 1st &quot;baz&quot; element
  firstbazelt=XML::XXPath.new(&quot;/bar/baz&quot;).first(rootelt)
  =&gt; &lt;baz key='work'&gt; ... &lt;/&gt;

  path2=XML::XXPath.new(&quot;@key2&quot;)

  path2.create_new(firstbazelt)
  =&gt; #&lt;XML::XXPath::Accessors::Attribute:0xb79116d0 @name=&quot;key2&quot;, @parent=&lt;baz key2='[unset]' key='work'&gt; ... &lt;/&gt;&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='[unset]' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
      &lt;/foo&gt;

  ## ok, new attribute node added

  ## same call again...
  path2.create_new(firstbazelt)
  XML::XXPathError: XPath (@key2): create_new and attribute already exists
        from ../lib/xml/../xml/xxpath/steps.rb:210:in `create_on'
        from ../lib/xml/../xml/xxpath/steps.rb:80:in `creator'
        from ../lib/xml/xxpath.rb:91:in `all'
        from ../lib/xml/xxpath.rb:70:in `first'
        from ../lib/xml/xxpath.rb:112:in `create_new'
  ## can't create that path anew again -- an element can't have more
  ## than one attribute with the same name

  ## the document hasn't changed
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='[unset]' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
      &lt;/foo&gt;

  ## create_new the same path as in the ensure_created example
  baz6elt=XML::XXPath.new(&quot;/bar/baz[6]&quot;).create_new(rootelt)
  =&gt; &lt;baz/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='[unset]' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
        &lt;/bar&gt;
      &lt;/foo&gt;

  ## ok, new &quot;bar&quot; element and 6th &quot;baz&quot; element inside it created

  XML::XXPath.new(&quot;baz[6]&quot;).create_new(baz6elt.parent)
  XML::XXPathError: XPath: baz[6]: create_new and element already exists
        from ../lib/xml/../xml/xxpath/steps.rb:162:in `create_on'
        from ../lib/xml/../xml/xxpath/steps.rb:80:in `creator'
        from ../lib/xml/xxpath.rb:91:in `all'
        from ../lib/xml/xxpath.rb:70:in `first'
        from ../lib/xml/xxpath.rb:112:in `create_new'
  ## yep, baz[6] already existed and thus couldn't be created once
  ## again

  ## but of course...
  XML::XXPath.new(&quot;/bar/baz[6]&quot;).create_new(rootelt)
  =&gt; &lt;baz/&gt;
  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
        &lt;baz key2='[unset]' key='work'&gt;Java&lt;/baz&gt;
        &lt;baz key='play'&gt;Ruby&lt;/baz&gt;
      &lt;/bar&gt;
    &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz key='work'/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
        &lt;/bar&gt;
        &lt;bar&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
          &lt;baz/&gt;
        &lt;/bar&gt;
      &lt;/foo&gt;

  ## this works because *all* path elements are newly created
</pre>
<p>
This feature is used in xml-mapping by node types like <a
href="../classes/XML/Mapping/ArrayNode.html">XML::Mapping::ArrayNode</a>,
which must create a new instance of the &quot;per-array element path&quot;
for each element of the array to be stored in an <a
href="../classes/XML.html">XML</a> tree.
</p>
<h3>Pathological Cases</h3>
<p>
What is created when the Path &quot;*&quot; is to be created inside an
empty <a href="../classes/XML.html">XML</a> element? The name of the
element to be created isn&#8217;t known, but still some element must be
created. The answer is that xml-xxpath creates a special
&quot;unspecified&quot; element whose name must be set by the caller
afterwards:
</p>
<pre>
  require 'xml/xxpath'

  d=REXML::Document.new &lt;&lt;EOS
    &lt;foo&gt;
      &lt;bar/&gt;
      &lt;bar/&gt;
    &lt;/foo&gt;
  EOS

  rootelt=d.root

  XML::XXPath.new(&quot;*&quot;).all(rootelt)
  =&gt; [&lt;bar/&gt;, &lt;bar/&gt;]
  ## ok

  XML::XXPath.new(&quot;bar/*&quot;).first(rootelt, :allow_nil=&gt;true)
  =&gt; nil
  ## ok, nothing there

  ## the same call with :ensure_created=&gt;true
  newelt = XML::XXPath.new(&quot;bar/*&quot;).first(rootelt, :ensure_created=&gt;true)
  =&gt; &lt;/&gt;

  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
          &lt;/&gt;
        &lt;/bar&gt;
      &lt;bar/&gt;
    &lt;/foo&gt;

  ## a new &quot;unspecified&quot; element was created
  newelt.unspecified?
  =&gt; true

  ## we must modify it to &quot;specify&quot; it
  newelt.name=&quot;new-one&quot;
  newelt.text=&quot;hello!&quot;
  newelt.unspecified?
  =&gt; false

  d.write($stdout,2)
      &lt;foo&gt;
      &lt;bar&gt;
          &lt;new-one&gt;hello!&lt;/new-one&gt;
        &lt;/bar&gt;
      &lt;bar/&gt;
    &lt;/foo&gt;

  ## you could also set unspecified to false explicitly, as in:
  newelt.unspecified=true
</pre>
<p>
The &quot;newelt&quot; object in the last example is an ordinary
REXML::Element. xml-xxpath mixes the &quot;unspecified&quot; attribute into
that class, as well as into the <a
href="../classes/XML/XXPath/Accessors/Attribute.html">XML::XXPath::Accessors::Attribute</a>
class mentioned above.
</p>
<h2>Implentation notes</h2>
<p>
<tt>doc/xpath_impl_notes.txt</tt> contains some documentation on the
implementation of xml-xxpath.
</p>
<h2>License</h2>
<p>
Ruby&#8217;s.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>