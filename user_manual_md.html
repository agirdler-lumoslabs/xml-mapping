<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>user_manual - XML::Mapping -- Simple, extensible Ruby-to-XML (and back) mapper</title>

<link href="./fonts.css" rel="stylesheet">
<link href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/navigation.js"></script>
<script src="./js/search_index.js"></script>
<script src="./js/search.js"></script>
<script src="./js/searcher.js"></script>
<script src="./js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-XML-MAPPING%3A+XML-to-object+%28and+back%29+Mapper+for+Ruby%2C+including+XPath+Interpreter">XML-MAPPING: XML-to-object (and back) Mapper for Ruby, including XPath Interpreter</a>
    <li><a href="#label-Download">Download</a>
    <li><a href="#label-Contents+of+this+Document">Contents of this Document</a>
    <li><a href="#label-Example">Example</a>
    <li><a href="#label-Input+Document%3A">Input Document:</a>
    <li><a href="#label-Mapping+Class+Declaration%3A">Mapping Class Declaration:</a>
    <li><a href="#label-Usage%3A">Usage:</a>
    <li><a href="#label-Single-attribute+Nodes">Single-attribute Nodes</a>
    <li><a href="#label-Default+Values">Default Values</a>
    <li><a href="#label-Single-attribute+Nodes+with+Sub-objects">Single-attribute Nodes with Sub-objects</a>
    <li><a href="#label-Polymorphic+Sub-objects%2C+Marshallers%2FUnmarshallers">Polymorphic Sub-objects, Marshallers/Unmarshallers</a>
    <li><a href="#label-Attribute+Handling+Details%2C+Augmenting+Existing+Classes">Attribute Handling Details, Augmenting Existing Classes</a>
    <li><a href="#label-Other+Nodes">Other Nodes</a>
    <li><a href="#label-choice_node">choice_node</a>
    <li><a href="#label-Readers%2FWriters">Readers/Writers</a>
    <li><a href="#label-Multiple+Mappings+per+Class">Multiple Mappings per Class</a>
    <li><a href="#label-Defining+your+own+Node+Types">Defining your own Node Types</a>
    <li><a href="#label-Example">Example</a>
    <li><a href="#label-Element+order+in+created+XML+documents">Element order in created XML documents</a>
    <li><a href="#label-Node+Types+Are+Ruby+Classes">Node Types Are Ruby Classes</a>
    <li><a href="#label-How+Node+Types+Work">How Node Types Work</a>
    <li><a href="#label-Node+Initialization">Node Initialization</a>
    <li><a href="#label-Node+Operation+during+Marshalling+and+Unmarshalling">Node Operation during Marshalling and Unmarshalling</a>
    <li><a href="#label-Basic+Node+Types+Overview">Basic Node Types Overview</a>
    <li><a href="#label-Node">Node</a>
    <li><a href="#label-SingleAttributeNode">SingleAttributeNode</a>
    <li><a href="#label-SubObjectBaseNode">SubObjectBaseNode</a>
    <li><a href="#label-XPath+Interpreter">XPath Interpreter</a>
    <li><a href="#label-License">License</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./README_md.html">README</a>
  
    <li><a href="./TODO_txt.html">TODO</a>
  
    <li><a href="./doc/xpath_impl_notes_txt.html">xpath_impl_notes</a>
  
    <li><a href="./user_manual_md.html">user_manual</a>
  
    <li><a href="./user_manual_xxpath_md.html">user_manual_xxpath</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page user_manual.md">

<h1 id="label-XML-MAPPING%3A+XML-to-object+%28and+back%29+Mapper+for+Ruby%2C+including+XPath+Interpreter">XML-MAPPING: XML-to-object (and back) Mapper for Ruby, including XPath Interpreter<span><a href="#label-XML-MAPPING%3A+XML-to-object+%28and+back%29+Mapper+for+Ruby%2C+including+XPath+Interpreter">&para;</a> <a href="#documentation">&uarr;</a></span></h1>

<p>Xml-mapping is an easy to use, extensible library that allows you to
semi-automatically map Ruby objects to <a href="XML.html">XML</a> trees and
vice versa.</p>

<h2 id="label-Download">Download<span><a href="#label-Download">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>For downloading the latest version, git repository access etc. go to:</p>

<p><a
href="https://github.com/multi-io/xml-mapping">github.com/multi-io/xml-mapping</a></p>

<h2 id="label-Contents+of+this+Document">Contents of this Document<span><a href="#label-Contents+of+this+Document">&para;</a> <a href="#documentation">&uarr;</a></span></h2>
<ul><li>
<p><a href="#label-Example">Example</a></p>
</li><li>
<p><a href="#label-Single-attribute+Nodes">Single-attribute Nodes</a></p>
<ul><li>
<p><a href="#label-Default+Values">Default Values</a></p>
</li><li>
<p><a href="#label-Single-attribute+Nodes+with+Sub-objects">Single-attribute
Nodes with Sub-objects</a></p>
</li><li>
<p><a
href="#label-Attribute+Handling+Details%2C+Augmenting+Existing+Classes">Attribute
Handling Details, Augmenting Existing Classes</a></p>
</li></ul>
</li><li>
<p><a href="#label-Other+Nodes">Other Nodes</a></p>
<ul><li>
<p><a href="#label-choice_node">choice_node</a></p>
</li><li>
<p><a href="#label-Readers%2FWriters">Readers/Writers</a></p>
</li></ul>
</li><li>
<p><a href="#label-Multiple+Mappings+per+Class">Multiple Mappings per
Class</a></p>
</li><li>
<p><a href="#label-Defining+your+own+Node+Types">Defining your own Node
Types</a></p>
</li><li>
<p><a href="#label-XPath+Interpreter">XPath Interpreter</a></p>
</li></ul>

<h2 id="label-Example">Example<span><a href="#label-Example">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>(example document stolen + extended from <a
href="http://www.castor.org/xml-mapping.html">www.castor.org/xml-mapping.html</a>)</p>

<h3 id="label-Input+Document%3A">Input Document:<span><a href="#label-Input+Document%3A">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

&lt;Order reference=&quot;12343-AHSHE-314159&quot;&gt;
  &lt;Client&gt;
    &lt;Name&gt;Jean Smith&lt;/Name&gt;
    &lt;Address where=&quot;home&quot;&gt;
      &lt;City&gt;San Mateo&lt;/City&gt;
      &lt;State&gt;CA&lt;/State&gt;
      &lt;ZIP&gt;94403&lt;/ZIP&gt;
      &lt;Street&gt;2000, Alameda de las Pulgas&lt;/Street&gt;
    &lt;/Address&gt;
    &lt;Address where=&quot;work&quot;&gt;
      &lt;City&gt;San Francisco&lt;/City&gt;
      &lt;State&gt;CA&lt;/State&gt;
      &lt;ZIP&gt;94102&lt;/ZIP&gt;
      &lt;Street&gt;98765, Fulton Street&lt;/Street&gt;
    &lt;/Address&gt;
  &lt;/Client&gt;

  &lt;Item reference=&quot;RF-0001&quot;&gt;
    &lt;Description&gt;Stuffed Penguin&lt;/Description&gt;
    &lt;Quantity&gt;10&lt;/Quantity&gt;
    &lt;UnitPrice&gt;8.95&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=&quot;RF-0034&quot;&gt;
    &lt;Description&gt;Chocolate&lt;/Description&gt;
    &lt;Quantity&gt;5&lt;/Quantity&gt;
    &lt;UnitPrice&gt;28.50&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=&quot;RF-3341&quot;&gt;
    &lt;Description&gt;Cookie&lt;/Description&gt;
    &lt;Quantity&gt;30&lt;/Quantity&gt;
    &lt;UnitPrice&gt;0.85&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Signed-By&gt;
    &lt;Signature&gt;
      &lt;Name&gt;John Doe&lt;/Name&gt;
      &lt;Position&gt;product manager&lt;/Position&gt;
    &lt;/Signature&gt;

    &lt;Signature&gt;
      &lt;Name&gt;Jill Smith&lt;/Name&gt;
      &lt;Position&gt;clerk&lt;/Position&gt;
    &lt;/Signature&gt;

    &lt;Signature&gt;
      &lt;Name&gt;Miles O&#39;Brien&lt;/Name&gt;
    &lt;/Signature&gt;
  &lt;/Signed-By&gt;

&lt;/Order&gt;</pre>

<h3 id="label-Mapping+Class+Declaration%3A">Mapping Class Declaration:<span><a href="#label-Mapping+Class+Declaration%3A">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;xml/mapping&#39;</span>

<span class="ruby-comment">## forward declarations</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Address</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Item</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Signature</span>; <span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Order</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">reference</span>, <span class="ruby-string">&quot;@reference&quot;</span>
  <span class="ruby-identifier">object_node</span> :<span class="ruby-identifier">client</span>, <span class="ruby-string">&quot;Client&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Client</span>
  <span class="ruby-identifier">hash_node</span> :<span class="ruby-identifier">items</span>, <span class="ruby-string">&quot;Item&quot;</span>, <span class="ruby-string">&quot;@reference&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Item</span>
  <span class="ruby-identifier">array_node</span> :<span class="ruby-identifier">signatures</span>, <span class="ruby-string">&quot;Signed-By&quot;</span>, <span class="ruby-string">&quot;Signature&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Signature</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span>[]

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">total_price</span>
    <span class="ruby-identifier">items</span>.<span class="ruby-identifier">values</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">total_price</span>}.<span class="ruby-identifier">inject</span>(<span class="ruby-value">0</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">+</span><span class="ruby-identifier">y</span>}
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;Name&quot;</span>
  <span class="ruby-identifier">object_node</span> :<span class="ruby-identifier">home_address</span>, <span class="ruby-string">&quot;Address[@where=&#39;home&#39;]&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Address</span>
  <span class="ruby-identifier">object_node</span> :<span class="ruby-identifier">work_address</span>, <span class="ruby-string">&quot;Address[@where=&#39;work&#39;]&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Address</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Address</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">city</span>, <span class="ruby-string">&quot;City&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">state</span>, <span class="ruby-string">&quot;State&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">zip</span>, <span class="ruby-string">&quot;ZIP&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">street</span>, <span class="ruby-string">&quot;Street&quot;</span>
<span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Item</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">descr</span>, <span class="ruby-string">&quot;Description&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">quantity</span>, <span class="ruby-string">&quot;Quantity&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">unit_price</span>, <span class="ruby-string">&quot;UnitPrice&quot;</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">total_price</span>
    <span class="ruby-identifier">quantity</span><span class="ruby-operator">*</span><span class="ruby-identifier">unit_price</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Signature</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;Name&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">position</span>, <span class="ruby-string">&quot;Position&quot;</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;Some Employee&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Usage%3A">Usage:<span><a href="#label-Usage%3A">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-comment">####read access</span>
<span class="ruby-identifier">o</span>=<span class="ruby-constant">Order</span>.<span class="ruby-identifier">load_from_file</span>(<span class="ruby-string">&quot;order.xml&quot;</span>) 
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Order:0x007fb01549d438 @signatures=[#&lt;Signature:0x007fb015493b68 @position=&quot;product manager&quot;, @name=&quot;John Doe&quot;&gt;, #&lt;Signature:0x007fb015492c68 @position=&quot;clerk&quot;, @name=&quot;Jill Smith&quot;&gt;, #&lt;Signature:0x007fb015491a20 @position=&quot;Some Employee&quot;, @name=&quot;Miles O&#39;Brien&quot;&gt;], @reference=&quot;12343-AHSHE-314159&quot;, @client=#&lt;Client:0x007fb01549c998 @work_address=#&lt;Address:0x007fb01549a238 @city=&quot;San Francisco&quot;, @state=&quot;CA&quot;, @zip=94102, @street=&quot;98765, Fulton Street&quot;&gt;, @name=&quot;Jean Smith&quot;, @home_address=#&lt;Address:0x007fb01549bbb0 @city=&quot;San Mateo&quot;, @state=&quot;CA&quot;, @zip=94403, @street=&quot;2000, Alameda de las Pulgas&quot;&gt;&gt;, @items={&quot;RF-0001&quot;=&gt;#&lt;Item:0x007fb0154989b0 @descr=&quot;Stuffed Penguin&quot;, @quantity=10, @unit_price=8.95&gt;, &quot;RF-0034&quot;=&gt;#&lt;Item:0x007fb015496638 @descr=&quot;Chocolate&quot;, @quantity=5, @unit_price=28.5&gt;, &quot;RF-3341&quot;=&gt;#&lt;Item:0x007fb015495300 @descr=&quot;Cookie&quot;, @quantity=30, @unit_price=0.85&gt;}&gt;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">reference</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;12343-AHSHE-314159&quot;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Client:0x007fb01549c998 @work_address=#&lt;Address:0x007fb01549a238 @city=&quot;San Francisco&quot;, @state=&quot;CA&quot;, @zip=94102, @street=&quot;98765, Fulton Street&quot;&gt;, @name=&quot;Jean Smith&quot;, @home_address=#&lt;Address:0x007fb01549bbb0 @city=&quot;San Mateo&quot;, @state=&quot;CA&quot;, @zip=94403, @street=&quot;2000, Alameda de las Pulgas&quot;&gt;&gt;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>.<span class="ruby-identifier">keys</span> 
=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;RF-0001&quot;</span>, <span class="ruby-string">&quot;RF-0034&quot;</span>, <span class="ruby-string">&quot;RF-3341&quot;</span>]
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&quot;RF-0034&quot;</span>].<span class="ruby-identifier">descr</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Chocolate&quot;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&quot;RF-0034&quot;</span>].<span class="ruby-identifier">total_price</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-value">142.5</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">signatures</span> 
=<span class="ruby-operator">&gt;</span> [<span class="ruby-comment">#&lt;Signature:0x007fb015493b68 @position=&quot;product manager&quot;, @name=&quot;John Doe&quot;&gt;, #&lt;Signature:0x007fb015492c68 @position=&quot;clerk&quot;, @name=&quot;Jill Smith&quot;&gt;, #&lt;Signature:0x007fb015491a20 @position=&quot;Some Employee&quot;, @name=&quot;Miles O&#39;Brien&quot;&gt;]</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">signatures</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">name</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Miles O&#39;Brien&quot;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">signatures</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">position</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;Some Employee&quot;</span>
<span class="ruby-comment">## default value was set</span>

<span class="ruby-identifier">o</span>.<span class="ruby-identifier">total_price</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-value">257.5</span>

<span class="ruby-comment">####write access</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">name</span>=<span class="ruby-string">&quot;James T. Kirk&quot;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&#39;RF-4711&#39;</span>] = <span class="ruby-constant">Item</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&#39;RF-4711&#39;</span>].<span class="ruby-identifier">descr</span> = <span class="ruby-string">&#39;power transfer grid&#39;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&#39;RF-4711&#39;</span>].<span class="ruby-identifier">quantity</span> = <span class="ruby-value">2</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&#39;RF-4711&#39;</span>].<span class="ruby-identifier">unit_price</span> = <span class="ruby-value">29.95</span>

<span class="ruby-identifier">s</span>=<span class="ruby-constant">Signature</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">name</span>=<span class="ruby-string">&#39;Harry Smith&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">position</span>=<span class="ruby-string">&#39;general manager&#39;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">signatures</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">s</span>
<span class="ruby-identifier">xml</span>=<span class="ruby-identifier">o</span>.<span class="ruby-identifier">save_to_xml</span> <span class="ruby-comment">#convert to REXML node; there&#39;s also o.save_to_file(name) </span>
=<span class="ruby-operator">&gt;</span> <span class="ruby-operator">&lt;</span><span class="ruby-identifier">order</span> <span class="ruby-identifier">reference</span>=<span class="ruby-string">&#39;12343-AHSHE-314159&#39;</span><span class="ruby-operator">&gt;</span> <span class="ruby-operator">...</span> <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/&gt;
xml.write($stdout,2) 
&lt;order reference=&#39;12343-AHSHE-314159&#39;&gt;
  &lt;Client&gt;
    &lt;Name&gt;
      James T. Kirk
    &lt;/</span><span class="ruby-constant">Name</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Address</span> <span class="ruby-identifier">where</span>=<span class="ruby-string">&#39;home&#39;</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">City</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-constant">San</span> <span class="ruby-constant">Mateo</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/City&gt;
      &lt;State&gt;
        CA
      &lt;/</span><span class="ruby-constant">State</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">ZIP</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-value">94403</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/ZIP&gt;
      &lt;Street&gt;
        2000, Alameda de las Pulgas
      &lt;/</span><span class="ruby-constant">Street</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Address&gt;
    &lt;Address where=&#39;work&#39;&gt;
      &lt;City&gt;
        San Francisco
      &lt;/</span><span class="ruby-constant">City</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">State</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-constant">CA</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/State&gt;
      &lt;ZIP&gt;
        94102
      &lt;/</span><span class="ruby-constant">ZIP</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">Street</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-value">98765</span>, <span class="ruby-constant">Fulton</span> <span class="ruby-constant">Street</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Street&gt;
    &lt;/</span><span class="ruby-constant">Address</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Client&gt;
  &lt;Item reference=&#39;RF-0001&#39;&gt;
    &lt;Description&gt;
      Stuffed Penguin
    &lt;/</span><span class="ruby-constant">Description</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Quantity</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-value">10</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Quantity&gt;
    &lt;UnitPrice&gt;
      8.95
    &lt;/</span><span class="ruby-constant">UnitPrice</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Item&gt;
  &lt;Item reference=&#39;RF-0034&#39;&gt;
    &lt;Description&gt;
      Chocolate
    &lt;/</span><span class="ruby-constant">Description</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Quantity</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-value">5</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Quantity&gt;
    &lt;UnitPrice&gt;
      28.5
    &lt;/</span><span class="ruby-constant">UnitPrice</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Item&gt;
  &lt;Item reference=&#39;RF-3341&#39;&gt;
    &lt;Description&gt;
      Cookie
    &lt;/</span><span class="ruby-constant">Description</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Quantity</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-value">30</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Quantity&gt;
    &lt;UnitPrice&gt;
      0.85
    &lt;/</span><span class="ruby-constant">UnitPrice</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Item&gt;
  &lt;Item reference=&#39;RF-4711&#39;&gt;
    &lt;Description&gt;
      power transfer grid
    &lt;/</span><span class="ruby-constant">Description</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Quantity</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-value">2</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Quantity&gt;
    &lt;UnitPrice&gt;
      29.95
    &lt;/</span><span class="ruby-constant">UnitPrice</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Item&gt;
  &lt;Signed-By&gt;
    &lt;Signature&gt;
      &lt;Name&gt;
        John Doe
      &lt;/</span><span class="ruby-constant">Name</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">Position</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-identifier">product</span> <span class="ruby-identifier">manager</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Position&gt;
    &lt;/</span><span class="ruby-constant">Signature</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Signature</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">Name</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-constant">Jill</span> <span class="ruby-constant">Smith</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Name&gt;
      &lt;Position&gt;
        clerk
      &lt;/</span><span class="ruby-constant">Position</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Signature&gt;
    &lt;Signature&gt;
      &lt;Name&gt;
        Miles O&amp;apos;Brien
      &lt;/</span><span class="ruby-constant">Name</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Signature&gt;
    &lt;Signature&gt;
      &lt;Name&gt;
        Harry Smith
      &lt;/</span><span class="ruby-constant">Name</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">Position</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-identifier">general</span> <span class="ruby-identifier">manager</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Position&gt;
    &lt;/</span><span class="ruby-constant">Signature</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Signed-By&gt;
&lt;/o</span><span class="ruby-identifier">rder</span><span class="ruby-operator">&gt;</span>


<span class="ruby-comment">####Starting a new order from scratch</span>
<span class="ruby-identifier">o</span> = <span class="ruby-constant">Order</span>.<span class="ruby-identifier">new</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Order:0x007fb0153bfef8 @signatures=[]&gt;</span>
<span class="ruby-comment">## attributes with default values (here: signatures) are set</span>
<span class="ruby-comment">## automatically</span>

<span class="ruby-identifier">xml</span>=<span class="ruby-identifier">o</span>.<span class="ruby-identifier">save_to_xml</span> 
<span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">MappingError</span><span class="ruby-operator">:</span> <span class="ruby-identifier">no</span> <span class="ruby-identifier">value</span>, <span class="ruby-keyword">and</span> <span class="ruby-identifier">no</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">value</span>, <span class="ruby-keyword">for</span> <span class="ruby-identifier">attribute</span><span class="ruby-operator">:</span> <span class="ruby-identifier">reference</span>
    <span class="ruby-identifier">from</span> <span class="ruby-regexp">/home/o</span><span class="ruby-identifier">laf</span><span class="ruby-operator">/</span><span class="ruby-identifier">xml</span><span class="ruby-operator">-</span><span class="ruby-identifier">mapping</span><span class="ruby-operator">/</span><span class="ruby-identifier">lib</span><span class="ruby-operator">/</span><span class="ruby-identifier">xml</span><span class="ruby-operator">/</span><span class="ruby-identifier">mapping</span><span class="ruby-operator">/</span><span class="ruby-identifier">base</span>.<span class="ruby-identifier">rb</span>:<span class="ruby-value">712</span><span class="ruby-operator">:</span><span class="ruby-keyword">in</span> <span class="ruby-value">%xobj_to_xml&#39;
    from /home/olaf/xml-mapping/lib/xml/mapping/base.rb:218:in `</span><span class="ruby-identifier">block</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">fill_into_xml</span><span class="ruby-string">&#39;
    from /home/olaf/xml-mapping/lib/xml/mapping/base.rb:217:in `each&#39;</span>
    <span class="ruby-identifier">from</span> <span class="ruby-regexp">/home/o</span><span class="ruby-identifier">laf</span><span class="ruby-operator">/</span><span class="ruby-identifier">xml</span><span class="ruby-operator">-</span><span class="ruby-identifier">mapping</span><span class="ruby-operator">/</span><span class="ruby-identifier">lib</span><span class="ruby-operator">/</span><span class="ruby-identifier">xml</span><span class="ruby-operator">/</span><span class="ruby-identifier">mapping</span><span class="ruby-operator">/</span><span class="ruby-identifier">base</span>.<span class="ruby-identifier">rb</span>:<span class="ruby-value">217</span><span class="ruby-operator">:</span><span class="ruby-keyword">in</span> <span class="ruby-value">%xfill_into_xml&#39;
    from /home/olaf/xml-mapping/lib/xml/mapping/base.rb:229:in `</span><span class="ruby-identifier">save_to_xml</span><span class="ruby-string">&#39;
## can&#39;</span><span class="ruby-identifier">t</span> <span class="ruby-identifier">save</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">long</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">there</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">still</span> <span class="ruby-identifier">unset</span> <span class="ruby-identifier">attributes</span> <span class="ruby-identifier">without</span>
<span class="ruby-comment">## default values</span>

<span class="ruby-identifier">o</span>.<span class="ruby-identifier">reference</span> = <span class="ruby-string">&quot;FOOBAR-1234&quot;</span>

<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">name</span> = <span class="ruby-string">&#39;Ford Prefect&#39;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">home_address</span> = <span class="ruby-constant">Address</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">home_address</span>.<span class="ruby-identifier">street</span> = <span class="ruby-string">&#39;42 Park Av.&#39;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">home_address</span>.<span class="ruby-identifier">city</span> = <span class="ruby-string">&#39;small planet&#39;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">home_address</span>.<span class="ruby-identifier">zip</span> = <span class="ruby-value">17263</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">home_address</span>.<span class="ruby-identifier">state</span> = <span class="ruby-string">&#39;Betelgeuse system&#39;</span>

<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>={<span class="ruby-string">&#39;XY-42&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Item</span>.<span class="ruby-identifier">new</span>}
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&#39;XY-42&#39;</span>].<span class="ruby-identifier">descr</span> = <span class="ruby-string">&#39;improbability drive&#39;</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&#39;XY-42&#39;</span>].<span class="ruby-identifier">quantity</span> = <span class="ruby-value">3</span>
<span class="ruby-identifier">o</span>.<span class="ruby-identifier">items</span>[<span class="ruby-string">&#39;XY-42&#39;</span>].<span class="ruby-identifier">unit_price</span> = <span class="ruby-value">299.95</span>

<span class="ruby-identifier">xml</span>=<span class="ruby-identifier">o</span>.<span class="ruby-identifier">save_to_xml</span>
<span class="ruby-identifier">xml</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">$stdout</span>,<span class="ruby-value">2</span>)

<span class="ruby-operator">&lt;</span><span class="ruby-identifier">order</span> <span class="ruby-identifier">reference</span>=<span class="ruby-string">&#39;FOOBAR-1234&#39;</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-constant">Client</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Name</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-constant">Ford</span> <span class="ruby-constant">Prefect</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Name&gt;
    &lt;Address where=&#39;home&#39;&gt;
      &lt;City&gt;
        small planet
      &lt;/</span><span class="ruby-constant">City</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">State</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-constant">Betelgeuse</span> <span class="ruby-identifier">system</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/State&gt;
      &lt;ZIP&gt;
        17263
      &lt;/</span><span class="ruby-constant">ZIP</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-constant">Street</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-value">42</span> <span class="ruby-constant">Park</span> <span class="ruby-constant">Av</span>.
      <span class="ruby-operator">&lt;</span><span class="ruby-operator">/</span><span class="ruby-constant">Street</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Address&gt;
  &lt;/</span><span class="ruby-constant">Client</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-constant">Item</span> <span class="ruby-identifier">reference</span>=<span class="ruby-string">&#39;XY-42&#39;</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">Description</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-identifier">improbability</span> <span class="ruby-identifier">drive</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/Description&gt;
    &lt;Quantity&gt;
      3
    &lt;/</span><span class="ruby-constant">Quantity</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-constant">UnitPrice</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-value">299.95</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/UnitPrice&gt;
  &lt;/</span><span class="ruby-constant">Item</span><span class="ruby-operator">&gt;</span>
<span class="ruby-operator">&lt;</span><span class="ruby-node">/order&gt;
## the root element name when saving an object to XML will by default
## be derived from the class name (in this example, &quot;Order&quot; became
## &quot;order&quot;). This can be overridden on a per-class basis; see
## XML::Mapping::ClassMethods#root_element_name for details.
</span></pre>

<p>As shown in the example, you have to include XML::Mapping into a class to
turn it into a “mapping class”. There are no other restrictions imposed on
mapping classes; you can add attributes and methods to them, include
additional modules in them, derive them from other classes, derive other
classes from them etc.pp.</p>

<p>An instance of a mapping class can be created from/converted into an <a
href="XML.html">XML</a> node with methods like <a
href="XML/Mapping/ClassMethods.html#method-i-load_from_xml">XML::Mapping::ClassMethods#load_from_xml</a>,
<a
href="XML/Mapping.html#method-i-save_to_xml">XML::Mapping#save_to_xml</a>,
<a
href="XML/Mapping/ClassMethods.html#method-i-load_from_file">XML::Mapping::ClassMethods#load_from_file</a>,
<a
href="XML/Mapping.html#method-i-save_to_file">XML::Mapping#save_to_file</a>.
Special class methods like “text_node”, “array_node” etc., called
<em>node</em> <em>factory</em> <em>methods</em>, may be called from the
body of the class definition to define instance attributes that are
automatically and bidirectionally mapped to subtrees of the <a
href="XML.html">XML</a> element an instance of the class is mapped to.</p>

<h2 id="label-Single-attribute+Nodes">Single-attribute Nodes<span><a href="#label-Single-attribute+Nodes">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>For example, in the definition</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Address</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">city</span>, <span class="ruby-string">&quot;City&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">state</span>, <span class="ruby-string">&quot;State&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">zip</span>, <span class="ruby-string">&quot;ZIP&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">street</span>, <span class="ruby-string">&quot;Street&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>the first call to text_node creates an attribute named “city” which is
mapped to the text of the <a href="XML.html">XML</a> child element defined
by the XPath expression “City” (xml-mapping includes an XPath interpreter
that can also be used seperately; see <a href="aref:xpath">below</a>). When
you create an instance of <code>Address</code> from an <a
href="XML.html">XML</a> element (using Address.load_from_file(file_name) or
Address.load_from_xml(rexml_element)), that instance&#39;s “city” attribute
will be set to the text of the <a href="XML.html">XML</a> element&#39;s
“City” child element. When you convert an instance of <code>Address</code>
into an <a href="XML.html">XML</a> element, a sub-element “City” is added
and its text is set to the current value of the <code>city</code>
attribute. The other node types (numeric_node, array_node etc.) work
analogously. Generally said, when an instance of the above
<code>Address</code> class is created from or converted to an <a
href="XML.html">XML</a> tree, each of the four nodes in the class maps some
parts of that <a href="XML.html">XML</a> tree to a single, specific
attribute of the <code>Adress</code> instance. The name of that attribute
is given in the first argument to the node factory method. Such a node is
called a “single-attribute node”. All node types that come with xml-mapping
except one (<code>choice_node</code>, which I&#39;ll talk about below) are
single-attribute nodes.</p>

<h3 id="label-Default+Values">Default Values<span><a href="#label-Default+Values">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>For each single-attribute node you may define a <em>default value</em>
which will be set if there was no value defined for the attribute in the <a
href="XML.html">XML</a> source.</p>

<p>From the example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Signature</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">position</span>, <span class="ruby-string">&quot;Position&quot;</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;Some Employee&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The semantics of default values are as follows:</p>
<ul><li>
<p>when creating a new instance from scratch:</p>
<ul><li>
<p>attributes with default values are set to their default values</p>
</li><li>
<p>attributes without default values are left unset</p>
</li></ul>
</li></ul>

<p>(when defining your own initializer, you&#39;ll have to call the  inherited
<em>initialize</em> method in order to get this behaviour)</p>
<ul><li>
<p>when loading an instance from an <a href="XML.html">XML</a> document:</p>
<ul><li>
<p>attributes without default values that are not represented in  the <a
href="XML.html">XML</a> raise an error</p>
</li><li>
<p>attributes with default values that are not represented in the  <a
href="XML.html">XML</a> are set to their default values</p>
</li><li>
<p>all other attributes are set to their respective values as  present in the
<a href="XML.html">XML</a></p>
</li></ul>
</li><li>
<p>when saving an instance to an <a href="XML.html">XML</a> document:</p>
<ul><li>
<p>unset attributes without default values raise an error</p>
</li><li>
<p>attributes with default values that are set to their default  values are
not saved</p>
</li><li>
<p>all other attributes are saved</p>
</li></ul>
</li></ul>

<p>This implies that:</p>
<ul><li>
<p>attributes that are set to their respective default values are not 
represented in the <a href="XML.html">XML</a></p>
</li><li>
<p>attributes without default values must be set explicitly before  saving</p>
</li></ul>

<h3 id="label-Single-attribute+Nodes+with+Sub-objects">Single-attribute Nodes with Sub-objects<span><a href="#label-Single-attribute+Nodes+with+Sub-objects">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>Single-attribute nodes of type <code>array_node</code>,
<code>hash_node</code>, and <code>object_node</code> recursively map one or
more subtrees of their <a href="XML.html">XML</a> to sub-objects (e.g.
array elements or hash values) of their attribute. For example, with the
line</p>

<pre class="ruby"><span class="ruby-identifier">array_node</span> :<span class="ruby-identifier">signatures</span>, <span class="ruby-string">&quot;Signed-By&quot;</span>, <span class="ruby-string">&quot;Signature&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Signature</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span>[]
</pre>

<p>, an attribute named “signatures” is added to the surrounding class (here:
<code>Order</code>); the attribute will be an array whose elements
correspond to the <a href="XML.html">XML</a> sub-trees yielded by the XPath
expression “Signed-By/Signature” (relative to the tree corresponding to the
<code>Order</code> instance). Each element will be of class
<code>Signature</code> (internally, each element is created from its
corresponding <a href="XML.html">XML</a> subtree by just calling
<code>Signature.load_from_xml(the_subtree)</code>). The reason why the path
“Signed-By/Signature” is provided in two arguments instead of just one
combined one becomes apparent when marshalling the array (along with the
surrounding <code>Order</code> object) back into a sequence of <a
href="XML.html">XML</a> elements. When that happens, “Signed-By” names the
common base element for all those elements, and “Signature” is the path
that will be duplicated for each element. For example, when the
<code>signatures</code> attribute contains an array with 3
<code>Signature</code> instances (let&#39;s call them <code>sig1</code>,
<code>sig2</code>, and <code>sig3</code>) in it, it will be marshalled to
an <a href="XML.html">XML</a> tree that looks like this:</p>

<pre>&lt;Signed-By&gt;
  &lt;Signature&gt;
    [marshalled object sig1]
  &lt;/Signature&gt;
  &lt;Signature&gt;
    [marshalled object sig2]
  &lt;/Signature&gt;
  &lt;Signature&gt;
    [marshalled object sig3]
  &lt;/Signature&gt;
&lt;/Signed-By&gt;</pre>

<p>Internally, each <code>Signature</code> instance is stored into its
<code>&lt;Signature&gt;</code> sub-element by calling
<code>the_signature_instance.fill_into_xml(the_sub_element)</code>. The
input document in the example above shows how this ends up looking.</p>

<p><code>hash_node</code>s work similarly, but they define hash-valued
attributes instead of array-valued ones.</p>

<p><code>object_node</code>s are the simplest of the three types of
single-attribute nodes with sub-objects. They just map a single given
subtree directly to their attribute value. See the example for examples :)</p>

<p>The mentioned methods <code>load_from_xml</code> and
<code>fill_into_xml</code> are the only methods classes must implement in
order to be usable in the <code>:class=&gt;</code> keyword arguments to
node factory methods. Mapping classes (i.e. classes that <code>include
XML::Mapping</code>) automatically inherit those functions and can thus be
readily used in <code>:class=&gt;</code> arguments, as shown for the
<code>Signature</code> class in the <code>array_node</code> call above. In
addition to that, xml-mapping adds those methods to some of Ruby&#39;s core
classes, namely <code>String</code> and <code>Numeric</code> (and thus
<code>Float</code>, <code>Integer</code>, and <code>BigInt</code>). So you
can also use strings or numbers as sub-objects of attributes of
<code>array_node</code>, <code>hash_node</code>, or
<code>object_node</code> nodes. For example, say you have an <a
href="XML.html">XML</a> document like this one:</p>

<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

&lt;people&gt;
  &lt;names&gt;
    &lt;name&gt;Jim&lt;/name&gt;
    &lt;name&gt;Susan&lt;/name&gt;
    &lt;name&gt;Herbie&lt;/name&gt;
    &lt;name&gt;Nancy&lt;/name&gt;
  &lt;/names&gt;
&lt;/people&gt;</pre>

<p>, and you want to map all the names to a string array attribute
<code>names</code>, you could do it like this:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;xml/mapping&#39;</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">People</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>
  <span class="ruby-identifier">array_node</span> :<span class="ruby-identifier">names</span>, <span class="ruby-string">&quot;names&quot;</span>, <span class="ruby-string">&quot;name&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">String</span>
<span class="ruby-keyword">end</span>
</pre>

<p>usage:</p>

<pre class="ruby"><span class="ruby-identifier">ppl</span>=<span class="ruby-constant">People</span>.<span class="ruby-identifier">load_from_file</span>(<span class="ruby-string">&quot;stringarray.xml&quot;</span>) 
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;People:0x007fb015431a58 @names=[&quot;Jim&quot;, &quot;Susan&quot;, &quot;Herbie&quot;, &quot;Nancy&quot;]&gt;</span>
<span class="ruby-identifier">ppl</span>.<span class="ruby-identifier">names</span> 
=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;Jim&quot;</span>, <span class="ruby-string">&quot;Susan&quot;</span>, <span class="ruby-string">&quot;Herbie&quot;</span>, <span class="ruby-string">&quot;Nancy&quot;</span>]

<span class="ruby-identifier">ppl</span>.<span class="ruby-identifier">names</span>.<span class="ruby-identifier">concat</span> [<span class="ruby-string">&quot;Mary&quot;</span>,<span class="ruby-string">&quot;Arnold&quot;</span>] 
=<span class="ruby-operator">&gt;</span> [<span class="ruby-string">&quot;Jim&quot;</span>, <span class="ruby-string">&quot;Susan&quot;</span>, <span class="ruby-string">&quot;Herbie&quot;</span>, <span class="ruby-string">&quot;Nancy&quot;</span>, <span class="ruby-string">&quot;Mary&quot;</span>, <span class="ruby-string">&quot;Arnold&quot;</span>]
<span class="ruby-identifier">ppl</span>.<span class="ruby-identifier">save_to_xml</span>.<span class="ruby-identifier">write</span> <span class="ruby-identifier">$stdout</span>,<span class="ruby-value">2</span>

<span class="ruby-operator">&lt;</span><span class="ruby-identifier">people</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-identifier">names</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-constant">Jim</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/name&gt;
    &lt;name&gt;
      Susan
    &lt;/n</span><span class="ruby-identifier">ame</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-constant">Herbie</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/name&gt;
    &lt;name&gt;
      Nancy
    &lt;/n</span><span class="ruby-identifier">ame</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-constant">Mary</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/name&gt;
    &lt;name&gt;
      Arnold
    &lt;/n</span><span class="ruby-identifier">ame</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/names&gt;
&lt;/</span><span class="ruby-identifier">people</span><span class="ruby-operator">&gt;</span>
</pre>

<p>As a side node, this feature actually makes <code>text_node</code> and
<code>numeric_node</code> special cases of <code>object_node</code>. For
example, <code>text_node :attr, &quot;path&quot;</code> is the same as
<code>object_node :attr, &quot;path&quot;, :class=&gt;String</code>.</p>

<h4 id="label-Polymorphic+Sub-objects%2C+Marshallers%2FUnmarshallers">Polymorphic Sub-objects, Marshallers/Unmarshallers<span><a href="#label-Polymorphic+Sub-objects%2C+Marshallers%2FUnmarshallers">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>Besides the <code>:class</code> keyword argument, there are alternative
ways for a single-attribute node with sub-objects to specify the way the
sub-objects are created from/marshalled into their subtrees.</p>

<p>First, it&#39;s possible not to specify anything at all – in that case, the
class of a sub-object will be automatically deduced from the root element
name of its subtree. This allows you to achieve a kind of “polymorphic”,
late-bound way to decide about the sub-object&#39;s class. The following
example document contains a hierarchical, recursive set of named
“documents” and “folders”, where folders hold a set of entries, each of
which may again be either a document or a folder:</p>

<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

&lt;folder name=&quot;home&quot;&gt;
  &lt;document name=&quot;plan&quot;&gt;
    &lt;contents&gt; inhale, exhale&lt;/contents&gt;
  &lt;/document&gt;

  &lt;folder name=&quot;work&quot;&gt;
    &lt;folder name=&quot;xml-mapping&quot;&gt;
      &lt;document name=&quot;README&quot;&gt;
        &lt;contents&gt;foo bar baz&lt;/contents&gt;
      &lt;/document&gt;
    &lt;/folder&gt;
  &lt;/folder&gt;

&lt;/folder&gt;</pre>

<p>This can be mapped to Ruby like this:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;xml/mapping&#39;</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Entry</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;@name&quot;</span>
<span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Document</span> <span class="ruby-operator">&lt;</span><span class="ruby-constant">Entry</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">contents</span>, <span class="ruby-string">&quot;contents&quot;</span>
<span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Folder</span> <span class="ruby-operator">&lt;</span><span class="ruby-constant">Entry</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">array_node</span> :<span class="ruby-identifier">entries</span>, <span class="ruby-string">&quot;document|folder&quot;</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span>[]

  <span class="ruby-keyword">def</span> <span class="ruby-operator">[]</span>(<span class="ruby-identifier">name</span>)
    <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span><span class="ruby-identifier">e</span>.<span class="ruby-identifier">name</span><span class="ruby-operator">==</span><span class="ruby-identifier">name</span>}[<span class="ruby-value">0</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">append</span>(<span class="ruby-identifier">name</span>,<span class="ruby-identifier">entry</span>)
    <span class="ruby-identifier">entries</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">entry</span>
    <span class="ruby-identifier">entry</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>
    <span class="ruby-identifier">entry</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Usage:</p>

<pre class="ruby"><span class="ruby-identifier">root</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>.<span class="ruby-identifier">load_object_from_file</span> <span class="ruby-string">&quot;documents_folders.xml&quot;</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Folder:0x007fb015437098 @entries=[#&lt;Document:0x007fb015436148 @name=&quot;plan&quot;, @contents=&quot; inhale, exhale&quot;&gt;, #&lt;Folder:0x007fb0154352c0 @entries=[#&lt;Folder:0x007fb015434550 @entries=[#&lt;Document:0x007fb015432e30 @name=&quot;README&quot;, @contents=&quot;foo bar baz&quot;&gt;], @name=&quot;xml-mapping&quot;&gt;], @name=&quot;work&quot;&gt;], @name=&quot;home&quot;&gt;</span>
<span class="ruby-identifier">root</span>.<span class="ruby-identifier">name</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;home&quot;</span>
<span class="ruby-identifier">root</span>.<span class="ruby-identifier">entries</span> 
=<span class="ruby-operator">&gt;</span> [<span class="ruby-comment">#&lt;Document:0x007fb015436148 @name=&quot;plan&quot;, @contents=&quot; inhale, exhale&quot;&gt;, #&lt;Folder:0x007fb0154352c0 @entries=[#&lt;Folder:0x007fb015434550 @entries=[#&lt;Document:0x007fb015432e30 @name=&quot;README&quot;, @contents=&quot;foo bar baz&quot;&gt;], @name=&quot;xml-mapping&quot;&gt;], @name=&quot;work&quot;&gt;]</span>

<span class="ruby-identifier">root</span>.<span class="ruby-identifier">append</span> <span class="ruby-string">&quot;etc&quot;</span>, <span class="ruby-constant">Folder</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">root</span>[<span class="ruby-string">&quot;etc&quot;</span>].<span class="ruby-identifier">append</span> <span class="ruby-string">&quot;passwd&quot;</span>, <span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">root</span>[<span class="ruby-string">&quot;etc&quot;</span>][<span class="ruby-string">&quot;passwd&quot;</span>].<span class="ruby-identifier">contents</span> = <span class="ruby-string">&quot;foo:x:2:2:/bin/sh&quot;</span>
<span class="ruby-identifier">root</span>[<span class="ruby-string">&quot;etc&quot;</span>].<span class="ruby-identifier">append</span> <span class="ruby-string">&quot;hosts&quot;</span>, <span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">root</span>[<span class="ruby-string">&quot;etc&quot;</span>][<span class="ruby-string">&quot;hosts&quot;</span>].<span class="ruby-identifier">contents</span> = <span class="ruby-string">&quot;127.0.0.1 localhost&quot;</span>

<span class="ruby-identifier">xml</span> = <span class="ruby-identifier">root</span>.<span class="ruby-identifier">save_to_xml</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-operator">&lt;</span><span class="ruby-identifier">folder</span> <span class="ruby-identifier">name</span>=<span class="ruby-string">&#39;home&#39;</span><span class="ruby-operator">&gt;</span> <span class="ruby-operator">...</span> <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/&gt;
xml.write $stdout,2

&lt;folder name=&#39;home&#39;&gt;
  &lt;document name=&#39;plan&#39;&gt;
    &lt;contents&gt;
       inhale, exhale
    &lt;/</span><span class="ruby-identifier">contents</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/document&gt;
  &lt;folder name=&#39;work&#39;&gt;
    &lt;folder name=&#39;xml-mapping&#39;&gt;
      &lt;document name=&#39;README&#39;&gt;
        &lt;contents&gt;
          foo bar baz
        &lt;/</span><span class="ruby-identifier">contents</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/document&gt;
    &lt;/</span><span class="ruby-identifier">folder</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/folder&gt;
  &lt;folder name=&#39;etc&#39;&gt;
    &lt;document name=&#39;passwd&#39;&gt;
      &lt;contents&gt;
        foo:x:2:2:/</span><span class="ruby-identifier">bin</span><span class="ruby-operator">/</span><span class="ruby-identifier">sh</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/contents&gt;
    &lt;/</span><span class="ruby-identifier">document</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-identifier">document</span> <span class="ruby-identifier">name</span>=<span class="ruby-string">&#39;hosts&#39;</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-identifier">contents</span><span class="ruby-operator">&gt;</span>
        <span class="ruby-value">127.0</span><span class="ruby-value">.0</span><span class="ruby-value">.1</span> <span class="ruby-identifier">localhost</span>
      <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/contents&gt;
    &lt;/</span><span class="ruby-identifier">document</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/folder&gt;
&lt;/</span><span class="ruby-identifier">folder</span><span class="ruby-operator">&gt;</span>
</pre>

<p>As you see, the <code>Folder#entries</code> attribute is mapped via an
array_node that does not specify a <code>:class</code> or anything else to
govern the instantiation of the array&#39;s elements. This causes
xml-mapping to deduce the class of each array element from the root element
name of the corresponding <a href="XML.html">XML</a> tree. In this example,
the root element name is either “document” or “folder”. The mapping between
root element names and class names is the one briefly described in <a
href="aref:example">example</a> at the beginning of this document – the
unqualified class name is just converted to lower case and “dashed”, e.g.
Foo::Bar::MyClass becomes “my-class”; and you may overwrite this on a
per-class basis by calling <code>root_element_name
&quot;the-new-name&quot;</code> in the class body. In our example, the root
element name “document” leads to an instantiation of class
<code>Document</code>, and the root element name “folder” leads to an
instantiation of class <code>Folder</code>.</p>

<p>Incidentally, the last example shows that you can readily derive mapping
classes from one another (as said before, you can also derive mapping
classes from other classes, include other modules into them etc. at will).
This works just like intuition thinks it should – when deriving one mapping
class from another one, the list of nodes in effect when loading/saving
instances of the derived class will consist of all nodes of that class and
all superclasses, starting with the topmost superclass that has nodes
defined. There is one thing to take care of though: When deriving mapping
classes from one another, you have to make sure to <code>include
XML::Mapping</code> in each class. This requirement exists purely due to
ease-of-implementation considerations; there are probably ways to do away
with it, but the inconvenience seemed not severe enough for me to bother
(as yet). Still, you might get “strange” errors if you forget to do it for
a class.</p>

<p>Besides the <code>:class</code> keyword argument and no argument, there is
a third way to specify the way the sub-objects are created from/marshalled
into their subtrees: <code>:marshaller</code> and/or
<code>:unmarshaller</code> keyword arguments. Here you pass procs in which
you just do all the work manually. So this is basically a “catch-all” for
cases where the other two alternatives are not appropriate for the problem
at hand. (<em>TODO</em>: Use other example?) Let&#39;s say we want to
extend the <code>Signature</code> class from the initial example to include
the date on which the signature was created. We want the new <a
href="XML.html">XML</a> representation of such a signature to look like
this:</p>

<pre>&lt;Signature&gt;
  &lt;Name&gt;John Doe&lt;/Name&gt;
  &lt;Position&gt;product manager&lt;/Position&gt;
  &lt;signed-on&gt;
    &lt;day&gt;13&lt;/day&gt;
    &lt;month&gt;2&lt;/month&gt;
    &lt;year&gt;2005&lt;/year&gt;
  &lt;/signed-on&gt;
&lt;/Signature&gt;</pre>

<p>So, a new “signed-on” element was added that holds the day, month, and
year. In the <code>Signature</code> instance in Ruby, we want the date to
be stored in an attribute named <code>signed_on</code> of type
<code>Time</code> (that&#39;s Ruby&#39;s built-in <code>Time</code> class).</p>

<p>One could think of using <code>object_node</code>, but something like
<code>object_node :signed_on, &quot;signed-on&quot;, :class=&gt;Time</code>
won&#39;t work because <code>Time</code> isn&#39;t a mapping class and
doesn&#39;t define methods <code>load_from_xml</code> and
<code>fill_into_xml</code> (we could easily define those though; we&#39;ll
talk about that possibility <a href="aref:attrdefns">here</a> and <a
href="aref:definingnodes">here</a>). The fastest, most ad-hoc way to
achieve what we want are :marshaller and :unmarshaller keyword arguments,
like this:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;xml/mapping&#39;</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;xml/xxpath_methods&#39;</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Signature</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;Name&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">position</span>, <span class="ruby-string">&quot;Position&quot;</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;Some Employee&quot;</span>
  <span class="ruby-identifier">object_node</span> :<span class="ruby-identifier">signed_on</span>, <span class="ruby-string">&quot;signed-on&quot;</span>,
              :<span class="ruby-identifier">unmarshaller=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">xml</span><span class="ruby-operator">|</span>
                               <span class="ruby-identifier">y</span>,<span class="ruby-identifier">m</span>,<span class="ruby-identifier">d</span> = [<span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;year&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
                                        <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;month&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
                                        <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;day&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>]
                               <span class="ruby-constant">Time</span>.<span class="ruby-identifier">local</span>(<span class="ruby-identifier">y</span>,<span class="ruby-identifier">m</span>,<span class="ruby-identifier">d</span>)
                             },
              :<span class="ruby-identifier">marshaller=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">xml</span>,<span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
                             <span class="ruby-identifier">e</span> = <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">elements</span>.<span class="ruby-identifier">add</span>; <span class="ruby-identifier">e</span>.<span class="ruby-identifier">name</span> = <span class="ruby-string">&quot;year&quot;</span>; <span class="ruby-identifier">e</span>.<span class="ruby-identifier">text</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">year</span>
                             <span class="ruby-identifier">e</span> = <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">elements</span>.<span class="ruby-identifier">add</span>; <span class="ruby-identifier">e</span>.<span class="ruby-identifier">name</span> = <span class="ruby-string">&quot;month&quot;</span>; <span class="ruby-identifier">e</span>.<span class="ruby-identifier">text</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">month</span>
                             <span class="ruby-identifier">e</span> = <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">elements</span>.<span class="ruby-identifier">add</span>; <span class="ruby-identifier">e</span>.<span class="ruby-identifier">name</span> = <span class="ruby-string">&quot;day&quot;</span>; <span class="ruby-identifier">e</span>.<span class="ruby-identifier">text</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">day</span>

                             <span class="ruby-comment"># xml.first(&quot;year&quot;,:ensure_created=&gt;true).text = value.year</span>
                             <span class="ruby-comment"># xml.first(&quot;month&quot;,:ensure_created=&gt;true).text = value.month</span>
                             <span class="ruby-comment"># xml.first(&quot;day&quot;,:ensure_created=&gt;true).text = value.day</span>
                           }
<span class="ruby-keyword">end</span>
</pre>

<p>The <code>:unmarshaller</code> proc will be called whenever a
<code>Signature</code> instance is being read in from an <a
href="XML.html">XML</a> source. The <code>xml</code> argument passed to the
proc contains (as a REXML::Element instance) the <a href="XML.html">XML</a>
subtree corresponding to the node&#39;s attribute&#39;s sub-object
currently being read. In the case of our <code>object_node</code>, the
sub-object is just the node&#39;s attribute (<code>signed_on</code>)
itself, and the subtree is the one rooted at the &lt;signed-on&gt; element
(if this were e.g. an <code>array_node</code>, the
<code>:unmarshaller</code> proc would be called once for each array
element, and <code>xml</code> would hold the subtree corresponding to the
“current” array element). The proc is expected to extract the
sub-object&#39;s data from <code>xml</code> and return the sub-object. So
we have to read the “year”, “month”, and “day” elements, construct a
<code>Time</code> instance from them and return that. One could just use
the REXML API to do that, but I&#39;ve decided here to use the XPath
interpreter that comes with xml-mapping (xml/xxpath), and specifically the
&#39;xml/xxpath_methods&#39; utility library that adds methods like
<code>first</code> to REMXML::Element. We call <code>first</code> on
<code>xml</code> three times, passing XPath expressions to extract the
“year”/“month”/“day” sub-elements, construct the <code>Time</code> instance
from that and return it. The XPath library is explained in more detail <a
href="aref:xpath">below</a>.</p>

<p>The <code>:marshaller</code> proc will be called whenever a
<code>Signature</code> instance is being written into an <a
href="XML.html">XML</a> tree. <code>xml</code> is again the <a
href="XML.html">XML</a> subtree rooted at the &lt;signed-on&gt; element (it
will still be empty when this proc is called), and <code>value</code> is
the current value of the sub-object (again, since this is an
<code>object_node</code>, <code>value</code> is the node&#39;s attribute,
i.e. the <code>Time</code> instance). We have to fill <code>xml</code> with
the data from <code>value</code> here. So we add three elements “year”,
“month” and “day” and set their texts to the corresponding values from
<code>value</code>. The commented-out code shows an alternative
implementation of the same thing using the XPath interpreter.</p>

<p>It should be mentioned again that :marshaller/:unmarshaller procs are
possible with all single-attribute nodes with sub-objects, i.e. with
<code>object_node</code>, <code>array_node</code>, and
<code>hash_node</code>. So, if you wanted to map a whole array of date
values, you could use <code>array_node</code> with the same
:marshaller/:unmarshaller procs as above, for example:</p>

<pre class="ruby"><span class="ruby-identifier">array_node</span> :<span class="ruby-identifier">birthdays</span>, <span class="ruby-string">&quot;birthdays&quot;</span>, <span class="ruby-string">&quot;birthday&quot;</span>,
           :<span class="ruby-identifier">unmarshaller=</span><span class="ruby-operator">&gt;</span> <span class="ruby-operator">&lt;</span><span class="ruby-identifier">as</span> <span class="ruby-identifier">above</span><span class="ruby-operator">&gt;</span>,
           :<span class="ruby-identifier">marshaller=</span><span class="ruby-operator">&gt;</span> <span class="ruby-operator">&lt;</span><span class="ruby-identifier">as</span> <span class="ruby-identifier">above</span><span class="ruby-operator">&gt;</span>
</pre>

<p>You can see that :marshaller/:unmarshaller procs give you more flexibility,
but they also impose more work because you essentially have to do all the
work of marshalling/unmarshalling the sub-objects yourself. If you find
yourself copying and pasting marshaller/unmarshaller procs all over the
place, you should instead define your own node type or mix the
marshalling/unmarshalling capabilities into the <code>Time</code> class
itself. This is explained <a href="aref:attrdefns">here</a> and <a
href="aref:definingnodes">here</a>, and you&#39;ll see that it&#39;s not
really much more work than writing :marshaller and :unmarshaller procs (you
essentially just move the code from those procs into your own node type
resp. into the <code>Time</code> class), so you should not hesitate to do
this.</p>

<p>Another thing worth mentioning is that you don&#39;t have to specify
<em>both</em> a :marshaller and an :unmarshaller simultaneously. You can as
well give only one of them, and in addition to that pass a
<code>:class</code> argument or no argument. When you do that, the
specified marshaller (or unmarshaller) will be used when marshalling (resp.
unmarshalling) the sub-objects, and the other passed argument
(<code>:class</code> or none) will be employed when unmarshalling (resp.
marshalling) the sub-objects. So, in effect, you can deactivate or
“short-cut” some part of the marshalling/unmarshalling functionality of a
node type while retaining another part.</p>

<h3 id="label-Attribute+Handling+Details%2C+Augmenting+Existing+Classes">Attribute Handling Details, Augmenting Existing Classes<span><a href="#label-Attribute+Handling+Details%2C+Augmenting+Existing+Classes">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>I&#39;ll shed some more light on how single-attribute nodes add mapped
attributes to Ruby classes. An attribute declaration like</p>

<pre>text_node :city, &quot;City&quot;</pre>

<p>maps some portion of the <a href="XML.html">XML</a> tree (here: the “City”
sub-element) to an attribute (here: “city”) of the class whose body the
declaration appears in. When writing (marshalling) instances of the
surrounding class into an <a href="XML.html">XML</a> document, xml-mapping
will read the attribute value from the instance using the function named
<code>city</code>; when reading (unmarshalling) an instance from an <a
href="XML.html">XML</a> document, xml-mapping will use the one-parameter
function <code>city=</code> to set the attribute in the instance to the
value read from the <a href="XML.html">XML</a> document.</p>

<p>If these functions don&#39;t exist at the time the node declaration is
executed, xml-mapping adds default implementations that simply read/write
the attribute value to instance variables that have the same name as the
attribute. For example, the <code>city</code> attribute declaration in the
<code>Address</code> class in the example added functions <code>city</code>
and <code>city=</code> that read/write from/to the instance variable
<code>@city</code>.</p>

<p>If, however, these functions already exist prior to defining the
attributes, xml-mapping will leave them untouched, so your precious
self-written accessor methods that do whatever complicated internal
processing of the data won&#39;t be overwritten.</p>

<p>This means that you can not only create new mapping classes from scratch,
you can also take existing classes that contain some “business logic” and
“augment” them with xml-mapping capabilities. As a simple example,
let&#39;s augment Ruby&#39;s “Time” class with node declarations that
declare <a href="XML.html">XML</a> mappings for the day, month etc. fields:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Time</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">year</span>, <span class="ruby-string">&quot;year&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">month</span>, <span class="ruby-string">&quot;month&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">day</span>, <span class="ruby-string">&quot;mday&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">hour</span>, <span class="ruby-string">&quot;hours&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">min</span>, <span class="ruby-string">&quot;minutes&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">sec</span>, <span class="ruby-string">&quot;seconds&quot;</span>
<span class="ruby-keyword">end</span>


<span class="ruby-identifier">nowxml</span>=<span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">save_to_xml</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-operator">&lt;</span><span class="ruby-identifier">time</span><span class="ruby-operator">&gt;</span> <span class="ruby-operator">...</span> <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/&gt;
nowxml.write($stdout,2)
&lt;time&gt;
  &lt;year&gt;
    2014
  &lt;/</span><span class="ruby-identifier">year</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-identifier">month</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-value">9</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/month&gt;
  &lt;mday&gt;
    19
  &lt;/m</span><span class="ruby-identifier">day</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-identifier">hours</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-value">14</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/hours&gt;
  &lt;minutes&gt;
    1
  &lt;/minu</span><span class="ruby-identifier">tes</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-identifier">seconds</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-value">43</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/seconds&gt;
&lt;/</span><span class="ruby-identifier">time</span><span class="ruby-operator">&gt;</span>
</pre>

<p>Here <a href="XML.html">XML</a> mappings are defined for the existing
fields <code>year</code>, <code>month</code> etc. Xml-mapping noticed that
the getter methods for those attributes existed, so it didn&#39;t overwrite
them. When calling <code>save_to_xml</code> on a <code>Time</code> object,
these methods are called and return the object&#39;s values for those
fields, which then get written to the output <a href="XML.html">XML</a>.</p>

<p>So you can convert <code>Time</code> objects into <a
href="XML.html">XML</a> trees. What about reading them back in from <a
href="XML.html">XML</a>? All <a href="XML.html">XML</a> reading operations
go through <code>&lt;Class&gt;.load_from_xml</code>. The
<code>load_from_xml</code> class method inherited from XML::Mapping (see <a
href="XML/Mapping/ClassMethods.html#method-i-load_from_xml">XML::Mapping::ClassMethods#load_from_xml</a>)
allocates a new instance of the class (<code>Time</code>), then calls
<code>fill_from_xml</code> (i.e. <a
href="XML/Mapping.html#method-i-fill_from_xml">XML::Mapping#fill_from_xml</a>)
on it. <code>fill_from_xml</code> iterates over all our nodes in the order
of their definition. For each node, its data (the &lt;year&gt;, or
&lt;month&gt;, or &lt;day&gt; etc. element) is read from the <a
href="XML.html">XML</a> source and then written to the <code>Time</code>
instance via the respective setter method (<code>year=</code>,
<code>month=</code>, <code>day=</code> etc.). These methods didn&#39;t
exist in <code>Time</code> before (<code>Time</code> objects are
immutable), so xml-mapping defined its own, default setter methods that
just set <code>@year</code>, <code>@month</code> etc. This is of course
pretty useless because <code>Time</code> objects don&#39;t hold their time
in these variables, so the setter methods don&#39;t really change the time
of the <code>Time</code> object. So we have to redefine
<code>load_from_xml</code> for the <code>Time</code> class:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">load_from_xml</span>(<span class="ruby-identifier">xml</span>, <span class="ruby-identifier">options</span>={:<span class="ruby-identifier">mapping=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">_default</span>})
  <span class="ruby-identifier">year</span>,<span class="ruby-identifier">month</span>,<span class="ruby-identifier">day</span>,<span class="ruby-identifier">hour</span>,<span class="ruby-identifier">min</span>,<span class="ruby-identifier">sec</span> =
    [<span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;year&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
     <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;month&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
     <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;mday&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
     <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;hours&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
     <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;minutes&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
     <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">first_xpath</span>(<span class="ruby-string">&quot;seconds&quot;</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>]
  <span class="ruby-constant">Time</span>.<span class="ruby-identifier">local</span>(<span class="ruby-identifier">year</span>,<span class="ruby-identifier">month</span>,<span class="ruby-identifier">day</span>,<span class="ruby-identifier">hour</span>,<span class="ruby-identifier">min</span>,<span class="ruby-identifier">sec</span>)
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Other+Nodes">Other Nodes<span><a href="#label-Other+Nodes">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>All nodes I&#39;ve shown so far (node types text_node, numeric_node,
boolean_node, object_node, array_node, and hash_node) were single-attribute
nodes: The first parameter to the node factory method of such a node is an
attribute name, and the attribute of that name is the only piece of the
state of instances of the node&#39;s mapping class that gets read/written
by the node.</p>

<h3 id="label-choice_node">choice_node<span><a href="#label-choice_node">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>There is one node type distributed with xml-mapping that is not a
single-attribute node: <code>choice_node</code>. A <code>choice_node</code>
allows you to specify a sequence of pairs, each consisting of an XPath
expression and another node (any node is supported here, including other
choice_nodes). When reading in an <a href="XML.html">XML</a> source, the
choice_node will delegate the work to the first node in the sequence whose
corresponding XPath expression was matched in the <a
href="XML.html">XML</a>. When writing an object back to <a
href="XML.html">XML</a>, the choice_node will delegate the work to the
first node whose data was “present” in the object (for single-attribute
nodes, the data is considered “present” if the node&#39;s attribute is
non-nil; for choice_nodes, the data is considered “present” if at least one
of the node&#39;s sub-nodes is “present”).</p>

<p>As a (somewhat contrived) example, here&#39;s a mapping for
<code>Publication</code> objects that have either a single author
(contained in an “author” <a href="XML.html">XML</a> attribute) or several
“contributors” (contained in a sequence of “contr” <a
href="XML.html">XML</a> elements):</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Publication</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">choice_node</span> :<span class="ruby-keyword">if</span>,    <span class="ruby-string">&#39;@author&#39;</span>, :<span class="ruby-keyword">then</span>, (<span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">author</span>, <span class="ruby-string">&#39;@author&#39;</span>),
              :<span class="ruby-keyword">elsif</span>, <span class="ruby-string">&#39;contr&#39;</span>,   :<span class="ruby-keyword">then</span>, (<span class="ruby-identifier">array_node</span> :<span class="ruby-identifier">contributors</span>, <span class="ruby-string">&#39;contr&#39;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">String</span>)
<span class="ruby-keyword">end</span>

<span class="ruby-comment">### usage</span>

<span class="ruby-identifier">p1</span> = <span class="ruby-constant">Publication</span>.<span class="ruby-identifier">load_from_xml</span>(<span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;&lt;publication author=&quot;Jim&quot;/&gt;&#39;</span>).<span class="ruby-identifier">root</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Publication:0x007fb01548e668 @author=&quot;Jim&quot;&gt;</span>

<span class="ruby-identifier">p2</span> = <span class="ruby-constant">Publication</span>.<span class="ruby-identifier">load_from_xml</span>(<span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;
&lt;publication&gt;
  &lt;contr&gt;Chris&lt;/contr&gt;
  &lt;contr&gt;Mel&lt;/contr&gt;
  &lt;contr&gt;Toby&lt;/contr&gt;
&lt;/publication&gt;&#39;</span>).<span class="ruby-identifier">root</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Publication:0x007fb01547ef38 @contributors=[&quot;Chris&quot;, &quot;Mel&quot;, &quot;Toby&quot;]&gt;</span>
</pre>

<p>The symbols :if, :then, and :elsif (but not :else – see below) in the
<code>choice_node</code>&#39;s node factory method call are ignored; they
may be sprinkled across the argument list at will (preferably the way shown
above of course) to increase readability.</p>

<p>The rest of the arguments specify the mentioned sequence of XPath
expressions and corresponding nodes.</p>

<p>When reading a <code>Publication</code> object from <a
href="XML.html">XML</a>, the XPath expressions from the
<code>choice_node</code> (<code>@author</code> and <code>contr</code>) will
be matched in sequence against the source <a href="XML.html">XML</a> tree
until a match is found or the end of the argument list is reached. If the
end is reached, an exception is raised. Otherwise, for the first XPath
expression that matched, the corresponding node will be invoked (i.e. used
to read actual data from the <a href="XML.html">XML</a> source into the
<code>Person</code> object). If you specify :else, :default, or :otherwise
in place of an XPath expression, this is treated as an XPath expression
that always matches. So you can use :else (or :default or :otherwise) for a
“fallback” node that will be used if none of the other XPath expressions
matched (an example for this follows).</p>

<p>When writing a <code>Publication</code> object back to <a
href="XML.html">XML</a>, the first node in the sequence whose data is
“present” in the source object will be invoked to write data from the
object into the target <a href="XML.html">XML</a> tree (and the
corresponding XPath expression will be created in the <a
href="XML.html">XML</a> tree if it doesn&#39;t exist already). If there is
no such node in the sequence, an exception is raised. As said above, for
single-attribute nodes, the node&#39;s data is considered “present” if the
node&#39;s attribute is non-nil. So, if you write a
<code>Publication</code> object to <a href="XML.html">XML</a>, and either
the <code>author</code> or the <code>contributors</code> attribute of the
object is set, it will be written; if both attributes are nil, an exception
will be raised.</p>

<p>A frequent use case for choice_nodes will probably be object attributes
that may be represented in multiple alternative ways in <a
href="XML.html">XML</a>. As an example, consider “Person” objects where the
name of the person should be stored alternatively in a sub-element named
<code>name</code>, or an attribute named <code>name</code>, or in the text
of the <code>person</code> element itself. You can achieve this with
<code>choice_node</code> like this:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Person</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">choice_node</span> :<span class="ruby-keyword">if</span>,    <span class="ruby-string">&#39;name&#39;</span>,  :<span class="ruby-keyword">then</span>, (<span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&#39;name&#39;</span>),
              :<span class="ruby-keyword">elsif</span>, <span class="ruby-string">&#39;@name&#39;</span>, :<span class="ruby-keyword">then</span>, (<span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&#39;@name&#39;</span>),
              :<span class="ruby-keyword">else</span>,  (<span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&#39;.&#39;</span>)
<span class="ruby-keyword">end</span>

<span class="ruby-comment">### usage</span>

<span class="ruby-identifier">p1</span> = <span class="ruby-constant">Person</span>.<span class="ruby-identifier">load_from_xml</span>(<span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;&lt;person name=&quot;Jim&quot;/&gt;&#39;</span>).<span class="ruby-identifier">root</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Person:0x007fb014e95298 @name=&quot;Jim&quot;&gt;</span>

<span class="ruby-identifier">p2</span> = <span class="ruby-constant">Person</span>.<span class="ruby-identifier">load_from_xml</span>(<span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;&lt;person&gt;&lt;name&gt;James&lt;/name&gt;&lt;/person&gt;&#39;</span>).<span class="ruby-identifier">root</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Person:0x007fb014e847b8 @name=&quot;James&quot;&gt;</span>

<span class="ruby-identifier">p3</span> = <span class="ruby-constant">Person</span>.<span class="ruby-identifier">load_from_xml</span>(<span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;&lt;person&gt;Suzy&lt;/person&gt;&#39;</span>).<span class="ruby-identifier">root</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Person:0x007fb014e6c550 @name=&quot;Suzy&quot;&gt;</span>


<span class="ruby-identifier">p1</span>.<span class="ruby-identifier">save_to_xml</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">$stdout</span>)
<span class="ruby-operator">&lt;</span><span class="ruby-identifier">person</span><span class="ruby-operator">&gt;</span><span class="ruby-operator">&lt;</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Jim</span><span class="ruby-operator">&lt;</span><span class="ruby-regexp">/name&gt;&lt;/</span><span class="ruby-identifier">person</span><span class="ruby-operator">&gt;</span>
<span class="ruby-identifier">p2</span>.<span class="ruby-identifier">save_to_xml</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">$stdout</span>)
<span class="ruby-operator">&lt;</span><span class="ruby-identifier">person</span><span class="ruby-operator">&gt;</span><span class="ruby-operator">&lt;</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">James</span><span class="ruby-operator">&lt;</span><span class="ruby-regexp">/name&gt;&lt;/</span><span class="ruby-identifier">person</span><span class="ruby-operator">&gt;</span>
<span class="ruby-identifier">p3</span>.<span class="ruby-identifier">save_to_xml</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">$stdout</span>)
<span class="ruby-operator">&lt;</span><span class="ruby-identifier">person</span><span class="ruby-operator">&gt;</span><span class="ruby-operator">&lt;</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Suzy</span><span class="ruby-operator">&lt;</span><span class="ruby-regexp">/name&gt;&lt;/</span><span class="ruby-identifier">person</span><span class="ruby-operator">&gt;</span>
</pre>

<p>Here all sub-nodes of the choice_nodes are single-attribute nodes
(text_nodes) with the same attribute (<code>name</code>). As you see, when
writing persons to <a href="XML.html">XML</a>, the name is always stored in
a &lt;name&gt; sub-element. Of course, this is because that alternative
appears first in the choice_node.</p>

<h3 id="label-Readers%2FWriters">Readers/Writers<span><a href="#label-Readers%2FWriters">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>Finally, <em>all</em> nodes support keyword arguments :reader and :writer
which allow you to extend or completely override the reading and/or writing
functionality of the node with your own code. The :reader as well as the
:writer argument must be a proc that takes as its arguments the Ruby object
to be read/written (instance of the mapping class the node belongs to) and
the <a href="XML.html">XML</a> tree to be written to/read from. An optional
third argument may be specified – it will receive a proc that wraps the
default reader/writer functionality of the node.</p>

<p>The :reader proc is for reading (from the <a href="XML.html">XML</a> into
the object), the :writer proc is for writing (from the object into the <a
href="XML.html">XML</a>).</p>

<p>Here&#39;s a (really contrived) example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Foo</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;@name&quot;</span>, :<span class="ruby-identifier">reader=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">obj</span>,<span class="ruby-identifier">xml</span>,<span class="ruby-identifier">default_reader</span><span class="ruby-operator">|</span>
                                       <span class="ruby-identifier">default_reader</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">obj</span>,<span class="ruby-identifier">xml</span>)
                                       <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">&#39;more&#39;</span>]
                                     },
                            :<span class="ruby-identifier">writer=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">obj</span>,<span class="ruby-identifier">xml</span><span class="ruby-operator">|</span>
                                       <span class="ruby-identifier">xml</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">&#39;bar&#39;</span>] = <span class="ruby-node">&quot;hi #{obj.name} ho&quot;</span>
                                     }
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">f</span> = <span class="ruby-constant">Foo</span>.<span class="ruby-identifier">load_from_xml</span>(<span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;&lt;foo name=&quot;Jim&quot; more=&quot;XYZ&quot;/&gt;&#39;</span>).<span class="ruby-identifier">root</span>)
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Foo:0x007fb015460c40 @name=&quot;JimXYZ&quot;&gt;</span>

<span class="ruby-identifier">xml</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">save_to_xml</span> 
<span class="ruby-identifier">xml</span>.<span class="ruby-identifier">write</span> <span class="ruby-identifier">$stdout</span>,<span class="ruby-value">2</span> 
<span class="ruby-operator">&lt;</span><span class="ruby-identifier">foo</span> <span class="ruby-identifier">bar</span>=<span class="ruby-string">&#39;hi JimXYZ ho&#39;</span><span class="ruby-operator">/</span><span class="ruby-operator">&gt;</span>
</pre>

<p>So there&#39;s a “Foo” class with a text_node that would by default
(without the :reader and :writer proc) map the Ruby attribute “name” to the
<a href="XML.html">XML</a> attribute “name”. The :reader proc is invoked
when reading from <a href="XML.html">XML</a> into a <code>Foo</code>
object. The <code>xml</code> argument is the <a href="XML.html">XML</a>
tree, <code>obj</code> is the object. <code>default_reader</code> is the
proc that wraps the default reading functionality of the node. We invoke it
at the beginning. For this text_node, the default reading functionality is
to take the text of the “name” attribute of <code>xml</code> and put it
into the <code>name</code> attribute of <code>obj</code>. After that, we
take the text of the “more” attribute of <code>xml</code> and append it to
the <code>name</code> attribute of <code>obj</code>. So the <a
href="XML.html">XML</a> tree <code>&lt;foo name=&quot;Jim&quot;
more=&quot;XYZ&quot;/&gt;</code> is converted to a <code>Foo</code> object
with <code>name</code>=“JimXYZ”.</p>

<p>In our :writer proc, we only take <code>obj</code> (the <code>Foo</code>
object to be written to <a href="XML.html">XML</a>) and <code>xml</code>
(the <a href="XML.html">XML</a> tree the stuff is to be written to).
Analogously to the :reader, we could take a proc that wraps the default
writing functionality of the node, but we don&#39;t do that here–we
completely override the writing functionality with our own code, which just
takes the <code>name</code> attribute of the object and writes “hi &lt;the
name&gt; ho” to a <code>bar</code> <a href="XML.html">XML</a> attribute in
the <a href="XML.html">XML</a> tree (stupid example, I know).</p>

<p>As a special convention, if you specify both a :reader and a :writer for a
node, and in both cases you do /not/ call the default behaviour, then you
should use the generic node type <code>node</code>, e.g.:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">SomeClass</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-operator">...</span>.

  <span class="ruby-identifier">node</span> :<span class="ruby-identifier">reader=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">obj</span>,<span class="ruby-identifier">xml</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span>},
       :<span class="ruby-identifier">writer=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">obj</span>,<span class="ruby-identifier">xml</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span>}
<span class="ruby-keyword">end</span>
</pre>

<p>(since you&#39;re completely replacing both the reading and the writing
functionality, you&#39;re effectively replacing all the functionality of
the node, so it would be pointless and confusing to use one of the more
“specific” node types)</p>

<p>As you see, the purpose of readers and writers is to make it possible to
augment or override a node&#39;s functionality arbitrarily, so there
shouldn&#39;t be anything that&#39;s absolutely impossible to achieve with
xml-mapping. However, if you use readers and writers without invoking the
default behaviour, you really do everything manually, so you&#39;re not
doing any less work than you would do if you weren&#39;t using xml-mapping
at all. So you&#39;ll probably use readers and/or writers for those bits of
your mapping semantics that can&#39;t be achieved with xml-mapping&#39;s
predefined node types (an alternative approach might be to override the
<code>post_load</code> and/or <code>post_save</code> instance methods on
the mapping class – see the reference documentation).</p>

<p>An advice similar to the one given above for marshallers/unmarshallers
applies here as well: If you find yourself writing lots of readers and
writers that only differ in some easily parameterizable aspects, you should
think about defining your own node types. We talk about that <a
href="aref:definingnodes">below</a>, and it generally just means that you
move the (sensibly parameterized) code from your readers/writers to your
node types.</p>

<h2 id="label-Multiple+Mappings+per+Class">Multiple Mappings per Class<span><a href="#label-Multiple+Mappings+per+Class">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>Sometimes you might want to represent the same Ruby object in multiple
alternative ways in <a href="XML.html">XML</a>. For example, the name of a
“Person” object could be represented either in a “name” element or a “name”
attribute.</p>

<p>xml-mapping supports this by allowing you to define multiple disjoint
“mappings” for a mapping class. A mapping is by convention identified with
a symbol, e.g. <code>:my_mapping</code>, <code>:other_mapping</code> etc.,
and each mapping comprises a root element name and a set of node
definitions. In the body of a mapping class definition, you switch to
another mapping with <code>use_mapping :the_mapping</code>. All following
node declarations will be added to that mapping <em>unless</em> you specify
the option :mapping=&gt;:another_mapping for a node declaration (all node
types support that option). The default mapping (the mapping used if there
was no previous <code>use_mapping</code> in the class body) is named
<code>:_default</code>.</p>

<p>All the worker methods like <code>load_from_xml/file</code>,
<code>save_to_xml/file</code>, <code>load_object_from_xml/file</code>
support a <code>:mapping</code> keyword argument to specify the mapping,
which again defaults to <code>:_default</code>.</p>

<p>In the following example, we define two mappings (the default one and a
mapping named <code>:other</code>) for <code>Person</code> objects with a
name, an age and an address:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;xml/mapping&#39;</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Address</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Person</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-comment"># the default mapping. Stores the name and age in XML attributes,</span>
  <span class="ruby-comment"># and the address in a sub-element &quot;address&quot;.</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;@name&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">age</span>, <span class="ruby-string">&quot;@age&quot;</span>
  <span class="ruby-identifier">object_node</span> :<span class="ruby-identifier">address</span>, <span class="ruby-string">&quot;address&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Address</span>

  <span class="ruby-identifier">use_mapping</span> :<span class="ruby-identifier">other</span>

  <span class="ruby-comment"># the &quot;:other&quot; mapping. Non-default root element name; name and age</span>
  <span class="ruby-comment"># stored in XML elements; address stored in the person&#39;s element</span>
  <span class="ruby-comment"># itself</span>

  <span class="ruby-identifier">root_element_name</span> <span class="ruby-string">&quot;individual&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;name&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">age</span>, <span class="ruby-string">&quot;age&quot;</span>
  <span class="ruby-identifier">object_node</span> :<span class="ruby-identifier">address</span>, <span class="ruby-string">&quot;.&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Address</span>

  <span class="ruby-comment"># you could also specify the mapping on a per-node basis with the</span>
  <span class="ruby-comment"># :mapping option, e.g.:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># numeric_node :age, &quot;age&quot;, :mapping=&gt;:other</span>
<span class="ruby-keyword">end</span>


<span class="ruby-keyword">class</span> <span class="ruby-constant">Address</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-comment"># the default mapping.</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">street</span>, <span class="ruby-string">&quot;street&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">number</span>, <span class="ruby-string">&quot;number&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">city</span>, <span class="ruby-string">&quot;city&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">zip</span>, <span class="ruby-string">&quot;zip&quot;</span>

  <span class="ruby-identifier">use_mapping</span> :<span class="ruby-identifier">other</span>

  <span class="ruby-comment"># the &quot;:other&quot; mapping.</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">street</span>, <span class="ruby-string">&quot;street-name&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">number</span>, <span class="ruby-string">&quot;street-name/@number&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">city</span>, <span class="ruby-string">&quot;city-name&quot;</span>
  <span class="ruby-identifier">numeric_node</span> :<span class="ruby-identifier">zip</span>, <span class="ruby-string">&quot;city-name/@zip-code&quot;</span>
<span class="ruby-keyword">end</span>


<span class="ruby-comment">### usage</span>

<span class="ruby-comment">## XML representation of a person in the default mapping</span>
<span class="ruby-identifier">xml</span> = <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;
&lt;person name=&quot;Suzy&quot; age=&quot;28&quot;&gt;
  &lt;address&gt;
    &lt;street&gt;Abbey Road&lt;/street&gt;
    &lt;number&gt;72&lt;/number&gt;
    &lt;city&gt;London&lt;/city&gt;
    &lt;zip&gt;18827&lt;/zip&gt;
  &lt;/address&gt;
&lt;/person&gt;&#39;</span>).<span class="ruby-identifier">root</span>

<span class="ruby-comment">## load using the default mapping</span>
<span class="ruby-identifier">p</span> = <span class="ruby-constant">Person</span>.<span class="ruby-identifier">load_from_xml</span> <span class="ruby-identifier">xml</span> 
=<span class="ruby-operator">&gt;</span> <span class="ruby-comment">#&lt;Person:0x007fb015506640 @name=&quot;Suzy&quot;, @age=28, @address=#&lt;Address:0x007fb015505a38 @street=&quot;Abbey Road&quot;, @number=72, @city=&quot;London&quot;, @zip=18827&gt;&gt;</span>

<span class="ruby-comment">## save using the default mapping</span>
<span class="ruby-identifier">xml2</span> = <span class="ruby-identifier">p</span>.<span class="ruby-identifier">save_to_xml</span>
<span class="ruby-identifier">xml2</span>.<span class="ruby-identifier">write</span> <span class="ruby-identifier">$stdout</span>,<span class="ruby-value">2</span> 
<span class="ruby-operator">&lt;</span><span class="ruby-identifier">person</span> <span class="ruby-identifier">name</span>=<span class="ruby-string">&#39;Suzy&#39;</span> <span class="ruby-identifier">age</span>=<span class="ruby-string">&#39;28&#39;</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-identifier">address</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-identifier">street</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-constant">Abbey</span> <span class="ruby-constant">Road</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/street&gt;
    &lt;number&gt;
      72
    &lt;/num</span><span class="ruby-identifier">ber</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-identifier">city</span><span class="ruby-operator">&gt;</span>
      <span class="ruby-constant">London</span>
    <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/city&gt;
    &lt;zip&gt;
      18827
    &lt;/</span><span class="ruby-identifier">zip</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/address&gt;
&lt;/</span><span class="ruby-identifier">person</span><span class="ruby-operator">&gt;</span>
<span class="ruby-comment">## xml2 identical to xml</span>


<span class="ruby-comment">## now, save the same person to XML using the :other mapping...</span>
<span class="ruby-identifier">other_xml</span> = <span class="ruby-identifier">p</span>.<span class="ruby-identifier">save_to_xml</span> :<span class="ruby-identifier">mapping=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">other</span>
<span class="ruby-identifier">other_xml</span>.<span class="ruby-identifier">write</span> <span class="ruby-identifier">$stdout</span>,<span class="ruby-value">2</span> 
<span class="ruby-operator">&lt;</span><span class="ruby-identifier">individual</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-constant">Suzy</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/name&gt;
  &lt;age&gt;
    28
  &lt;/</span><span class="ruby-identifier">age</span><span class="ruby-operator">&gt;</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-identifier">street</span><span class="ruby-operator">-</span><span class="ruby-identifier">name</span> <span class="ruby-identifier">number</span>=<span class="ruby-string">&#39;72&#39;</span><span class="ruby-operator">&gt;</span>
    <span class="ruby-constant">Abbey</span> <span class="ruby-constant">Road</span>
  <span class="ruby-operator">&lt;</span><span class="ruby-regexp">/street-name&gt;
  &lt;city-name zip-code=&#39;18827&#39;&gt;
    London
  &lt;/</span><span class="ruby-identifier">city</span><span class="ruby-operator">-</span><span class="ruby-identifier">name</span><span class="ruby-operator">&gt;</span>
<span class="ruby-operator">&lt;</span><span class="ruby-node">/individual&gt;
## load it again using the :other mapping
p2 = Person.load_from_xml other_xml, :mapping=&gt;:other 
=&gt; #&lt;Person:0x007fb0154bad30 @name=&quot;Suzy&quot;, @age=28, @address=#&lt;Address:0x007fb0154b98e0 @street=&quot;Abbey Road&quot;, @number=72, @city=&quot;London&quot;, @zip=18827&gt;&gt;

## p2 identical to p
</span></pre>

<p>In this example, each of the two mappings contains nodes that map the same
set of Ruby attributes (name, age and address). This is probably what you
want most of the time (since you&#39;re normally defining multiple <a
href="XML.html">XML</a> mappings for the same Ruby data), but it&#39;s not
a necessity at all. When a mapping class is defined, xml-mapping will add
all Ruby attributes from all mappings to it.</p>

<p>You may have noticed that the <code>object_node</code>s in the
<code>Person</code> class apply the mapping they were themselves defined in
to their sub-ordinated class (<code>Address</code>). This is the case for
all <a href="aref:subobjnodes">Single-attribute Nodes with Sub-objects</a>
(<code>object_node</code>, <code>array_node</code> and
<code>hash_node</code>) unless you explicitly specify a different mapping
for the sub-object(s) using the option :sub_mapping, e.g.</p>

<pre class="ruby"><span class="ruby-identifier">object_node</span> :<span class="ruby-identifier">address</span>, <span class="ruby-string">&quot;address&quot;</span>, :<span class="ruby-keyword">class</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Address</span>, :<span class="ruby-identifier">sub_mapping=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">other</span>
</pre>

<h2 id="label-Defining+your+own+Node+Types">Defining your own Node Types<span><a href="#label-Defining+your+own+Node+Types">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>It&#39;s easy to write additional node types and register them with the
xml-mapping library (the following node types come with xml-mapping:
<code>node</code>, <code>text_node</code>, <code>numeric_node</code>,
<code>boolean_node</code>, <code>object_node</code>,
<code>array_node</code>, <code>hash_node</code>, <code>choice_node</code>).</p>

<p>I&#39;ll first show an example, then some more theoretical insight.</p>

<h3 id="label-Example">Example<span><a href="#label-Example">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>Let&#39;s say we want to extend the <code>Signature</code> class from the
example to include the time at which the signature was created. We want the
new <a href="XML.html">XML</a> representation of such a signature to look
like this:</p>

<pre>&lt;Signature&gt;
  &lt;Name&gt;John Doe&lt;/Name&gt;
  &lt;Position&gt;product manager&lt;/Position&gt;
  &lt;signed-on&gt;
    &lt;day&gt;13&lt;/day&gt;
    &lt;month&gt;2&lt;/month&gt;
    &lt;year&gt;2005&lt;/year&gt;
  &lt;/signed-on&gt;
&lt;/Signature&gt;</pre>

<p>(we only save year, month and day to make this example shorter), and the
mapping class declaration to look like this:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Signature</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">name</span>, <span class="ruby-string">&quot;Name&quot;</span>
  <span class="ruby-identifier">text_node</span> :<span class="ruby-identifier">position</span>, <span class="ruby-string">&quot;Position&quot;</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;Some Employee&quot;</span>
  <span class="ruby-identifier">time_node</span> :<span class="ruby-identifier">signed_on</span>, <span class="ruby-string">&quot;signed-on&quot;</span>, :<span class="ruby-identifier">default_value=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
<span class="ruby-keyword">end</span>
</pre>

<p>(i.e. a new “time_node” declaration was added).</p>

<p>We want this <code>time_node</code> call to define an attribute named
<code>signed_on</code> which holds the date value from the <a
href="XML.html">XML</a> document in an instance of class <code>Time</code>.</p>

<p>This node type can be defined with this piece of code:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;xml/mapping/base&#39;</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">TimeNode</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span><span class="ruby-operator">::</span><span class="ruby-constant">SingleAttributeNode</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
    <span class="ruby-identifier">path</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">args</span> = <span class="ruby-keyword">super</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
    <span class="ruby-ivar">@y_path</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">XXPath</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span><span class="ruby-operator">+</span><span class="ruby-string">&quot;/year&quot;</span>)
    <span class="ruby-ivar">@m_path</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">XXPath</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span><span class="ruby-operator">+</span><span class="ruby-string">&quot;/month&quot;</span>)
    <span class="ruby-ivar">@d_path</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">XXPath</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span><span class="ruby-operator">+</span><span class="ruby-string">&quot;/day&quot;</span>)
    <span class="ruby-identifier">args</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">extract_attr_value</span>(<span class="ruby-identifier">xml</span>)
    <span class="ruby-identifier">y</span>,<span class="ruby-identifier">m</span>,<span class="ruby-identifier">d</span> = <span class="ruby-identifier">default_when_xpath_err</span>{ [<span class="ruby-ivar">@y_path</span>.<span class="ruby-identifier">first</span>(<span class="ruby-identifier">xml</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
                                     <span class="ruby-ivar">@m_path</span>.<span class="ruby-identifier">first</span>(<span class="ruby-identifier">xml</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>,
                                     <span class="ruby-ivar">@d_path</span>.<span class="ruby-identifier">first</span>(<span class="ruby-identifier">xml</span>).<span class="ruby-identifier">text</span>.<span class="ruby-identifier">to_i</span>]
                                  }
    <span class="ruby-constant">Time</span>.<span class="ruby-identifier">local</span>(<span class="ruby-identifier">y</span>,<span class="ruby-identifier">m</span>,<span class="ruby-identifier">d</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">set_attr_value</span>(<span class="ruby-identifier">xml</span>, <span class="ruby-identifier">value</span>)
    <span class="ruby-ivar">@y_path</span>.<span class="ruby-identifier">first</span>(<span class="ruby-identifier">xml</span>,:<span class="ruby-identifier">ensure_created=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>).<span class="ruby-identifier">text</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">year</span>
    <span class="ruby-ivar">@m_path</span>.<span class="ruby-identifier">first</span>(<span class="ruby-identifier">xml</span>,:<span class="ruby-identifier">ensure_created=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>).<span class="ruby-identifier">text</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">month</span>
    <span class="ruby-ivar">@d_path</span>.<span class="ruby-identifier">first</span>(<span class="ruby-identifier">xml</span>,:<span class="ruby-identifier">ensure_created=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>).<span class="ruby-identifier">text</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">day</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>


<span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>.<span class="ruby-identifier">add_node_class</span> <span class="ruby-constant">TimeNode</span>
</pre>

<p>The last line registers the new node type with the xml-mapping library. The
name of the node factory method (“time_node”) is automatically derived from
the class name of the node type (“TimeNode”).</p>

<p>There will be one instance of the node type <code>TimeNode</code> per
<code>time_node</code> declaration per mapping class (not per mapping class
instance). That instance (the “node” for short) will be created by the node
factory method (<code>time_node</code>); there&#39;s no need to instantiate
the node type directly. The <code>time_node</code> method places the node
into the mapping class; the @owner attribute of the node is set to
reference the mapping class. The node factory method passes the mapping
class the node appears in (<code>Signature</code>), followed by its own
arguments, to the node&#39;s constructor. In the example, the
<code>time_node</code> method calls <code>TimeNode.new(Signature,
:signed_on, &quot;signed-on&quot;, :default_value=&gt;Time.now)</code>).
<code>new</code> of course creates the node and then delegates the
arguments to our initializer <code>initialize</code>. We first call the
superclass&#39;s initializer, which strips off from the argument list those
arguments it handles itself, and returns the remaining ones. In this case,
the superclass <a
href="XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>
handles the <code>Signature</code>, <code>:signed_on</code> and
<code>:default_value=&gt;Time.now</code> arguments – <code>Signature</code>
is stored into <code>@owner</code>, <code>:signed_on</code> is stored into
<code>@attrname</code>, and <code>{:default_value=&gt;Time.now}</code> is
stored into <code>@options</code>. The remaining argument list
<code>[&quot;signed-on&quot;]</code> is returned; we capture the
<code>&quot;signed-on&quot;</code> string in <em>path</em> (the rest of the
argument list (an empty array) we capture in <em>args</em> for returning it
at the end of the initializer. This isn&#39;t strictly necessary, it&#39;s
just a convention that a node class initializer should always return those
arguments it didn&#39;t handle itself). We&#39;ll interpret <em>path</em>
as an XPath expression that locates the time value relative to the parent
mapping object&#39;s <a href="XML.html">XML</a> tree (in this case, this
would be the <a href="XML.html">XML</a> tree rooted at the
<code>&lt;Signature&gt;</code> element, i.e. the tree the
<code>Signature</code> instance was read from). We&#39;ll later have to
read/store the year, month, and day values from
<code>path+&quot;/year&quot;</code>, <code>path+&quot;/month&quot;</code>,
and <code>path+&quot;/day&quot;</code>, respectively, so we create (and
precompile) three corresponding XPath expressions using <a
href="XML/XXPath.html#method-c-new">XML::XXPath.new</a> and store them into
member variables of the node. <a href="XML/XXPath.html">XML::XXPath</a> is
an XPath implementation that is bundled with xml-mapping. It is very
incomplete, but it supports writing (not just reading) of <a
href="XML.html">XML</a> nodes, which is needed to support writing data back
to <a href="XML.html">XML</a>. The <a
href="XML/XXPath.html">XML::XXPath</a> library is explained in more detail
<a href="aref:xpath">below</a>.</p>

<p>The <code>extract_attr_value</code> method is called whenever an instance
of the mapping class the node belongs to (<code>Signature</code> in the
example) is being created from an <a href="XML.html">XML</a> tree. The
parameter <em>xml</em> is that tree (again, this is the tree rooted at the
<code>&lt;Signature&gt;</code> element in this example). The method
implementation is expected to extract the single attribute&#39;s value from
<em>xml</em> and return it, or raise <a
href="XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
if the attribute was “unset” in the <a href="XML.html">XML</a> (this
exception tells the framework that the default value should be put in place
if it was defined), or raise any other exception to signal an error and
abort the whole process. Our superclass <a
href="XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>
will store the returned single attribute&#39;s value into the
<code>signed_on</code> attribute of the <code>Signature</code> instance
being read in. In our implementation, we apply the xpath expressions
created during initialization to <em>xml</em> (e.g.
<code>@y_path.first(xml)</code>). An expression
<em>xpath_expr</em>.first(<em>xml</em>) returns (as a REXML element) the
first sub-element of <em>xml</em> that matches <em>xpath_expr</em>, or
raises <a href="XML/XXPathError.html">XML::XXPathError</a> if there was no
such element. We apply REXML&#39;s <em>text</em> method to the returned
element to get out the element&#39;s text, convert it to integer, and
supply it to the constructor of the <code>Time</code> object to be
returned. As a side note, if an XPath expression matches <a
href="XML.html">XML</a> attributes, <a
href="XML/XXPath.html">XML::XXPath</a> methods like <em>first</em> will
return <a
href="XML/XXPath/Accessors/Attribute.html">XML::XXPath::Accessors::Attribute</a>
nodes that behave similarly to REXML::Element nodes, including support for
messages like <em>name</em> and <em>text</em>, so this would&#39;ve worked
also if our XPath expressions had referred to <a href="XML.html">XML</a>
attributes, not elements. The <code>default_when_xpath_err</code> thing
calls the supplied block and returns its value, but maps the exception <a
href="XML/XXPathError.html">XML::XXPathError</a> to the mentioned <a
href="XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
(any other exceptions fall through unchanged). As said above, <a
href="XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
is caught by the framework (more precisely, by our superclass <a
href="XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>),
and the default value is set if it was provided. So you should just wrap
<code>default_when_xpath_err</code> around any applications of XPath
expressions whose non-presence in the <a href="XML.html">XML</a> you want
to be considered a non-presence of the attribute you&#39;re trying to
extract. (XML::XXPath is designed to know knothing about XML::Mapping, so
it doesn&#39;t raise <a
href="XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>
directly)</p>

<p>The <code>set_attr_value</code> method is called whenever an instance of
the mapping class the node belongs to (<code>Signature</code> in the
example) is being stored into an <a href="XML.html">XML</a> tree. The
<em>xml</em> parameter is the <a href="XML.html">XML</a> tree (a REXML
element node; here this is again the tree rooted at the
<code>&lt;Signature&gt;</code> element); <em>value</em> is the current
value of the single attribute (in this example, the <code>signed_on</code>
attribute of the <code>Signature</code> instance being stored).
<em>xml</em> will most probably be “half-populated” by the time this method
is called – the framework calls the <code>set_attr_value</code> methods of
all nodes of a mapping class in the order of their definition, letting each
node fill its “bit” into <em>xml</em>. The method implementation is
expected to write <em>value</em> into (the correct sub-elements of)
<em>xml</em>, or raise an exception to signal an error and abort the whole
process. No default value handling is done here;
<code>set_attr_value</code> won&#39;t be called at all if the attribute had
been set to its default value. In our implementation we grab the year,
month and day values from <em>value</em> (which must be a
<code>Time</code>), and store it into the sub-elements of <em>xml</em>
identified by XPath expressions <code>@y_path</code>, <code>@m_path</code>
and <code>@d_path</code>, respectively. We do this by calling <a
href="XML/XXPath.html#method-i-first">XML::XXPath#first</a> with an
additional parameter <code>:ensure_created=&gt;true</code>. An expression
<em>xpath_expr</em>.first(<em>xml</em>,:ensure_created=&gt;true) works just
like <em>xpath_expr</em>.first(<em>xml</em>) if <em>xpath_expr</em> was
already present in <em>xml</em>. If it was not, it is created (preferably
at the end of <em>xml</em>&#39;s list of sub-nodes), and returned. See <a
href="aref:xpath">below</a> for a more detailed documentation of the XPath
interpreter.</p>

<h3 id="label-Element+order+in+created+XML+documents">Element order in created <a href="XML.html">XML</a> documents<span><a href="#label-Element+order+in+created+XML+documents">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>As just said, <a href="XML/XXPath.html">XML::XXPath</a>, when used to
create new <a href="XML.html">XML</a> nodes, generally appends those nodes
to the end of the list of subnodes of the node the xpath expression was
applied to. All xml-mapping nodes that come with xml-mapping use <a
href="XML/XXPath.html">XML::XXPath</a> when writing data to <a
href="XML.html">XML</a>, and therefore also append their data to the <a
href="XML.html">XML</a> data written by preceding nodes (the nodes are
invoked in the order of their definition). This means that, generally, your
output data will appear in the <a href="XML.html">XML</a> document in the
same order in which the corresponding xml-mapping node definitions appeared
in the mapping class (unless you used XPath expressions like <a
href="number">foo</a> which explicitly dictate a fixed position in the
sequence of <a href="XML.html">XML</a> nodes). For instance, in the
<code>Order</code> class from the example at the beginning of this
document, if we put the <code>:signatures</code> node <em>before</em> the
<code>:items</code> node, the <code>&lt;Signed-By&gt;</code> element will
appear <em>before</em> the sequence of <code>&lt;Item&gt;</code> elements
in the output <a href="XML.html">XML</a>.</p>

<p>The following is a more systematic overview of the basic node types. The
description is self-contained, so some information from the previous
section will be repeated.</p>

<h3 id="label-Node+Types+Are+Ruby+Classes">Node Types Are Ruby Classes<span><a href="#label-Node+Types+Are+Ruby+Classes">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>A node type is implemented as a Ruby class derived from <a
href="XML/Mapping/Node.html">XML::Mapping::Node</a> or one of its
subclasses.</p>

<p>The following node types (node classes) come with xml-mapping (they all
live in the XML::Mapping namespace, which I&#39;ve left out here for
brevity):</p>

<pre>Node
 +-SingleAttributeNode
 |  +-SubObjectBaseNode
 |  |  +-ObjectNode
 |  |  +-ArrayNode
 |  |  +-HashNode
 |  +-TextNode
 |  +-NumericNode
 |  +-BooleanNode
 +-ChoiceNode</pre>

<p><a href="XML/Mapping/Node.html">XML::Mapping::Node</a> is the base class
for all nodes, <a
href="XML/Mapping/SingleAttributeNode.html">XML::Mapping::SingleAttributeNode</a>
is the base class for <a href="aref:sanodes">single-attribute nodes</a>,
and <a
href="XML/Mapping/SubObjectBaseNode.html">XML::Mapping::SubObjectBaseNode</a>
is the base class for <a href="aref:subobjnodes">single-attribute nodes
with sub-objects</a>. <a
href="XML/Mapping/TextNode.html">XML::Mapping::TextNode</a>, <a
href="XML/Mapping/ArrayNode.html">XML::Mapping::ArrayNode</a> etc. are of
course the <code>text_node</code>, <code>array_node</code> etc. we&#39;ve
talked about in this document. When you&#39;ve written a new node class,
you register it with xml-mapping by calling
<code>XML::Mapping.add_node_class MyNode</code>. When you do that,
xml-mapping automatically defines the node factory method for your class –
the method&#39;s name (e.g. <code>my_node</code>) is derived from the
node&#39;s class name (e.g. Foo::Bar::MyNode) by stripping all parent
module names, and then converting capital letters to lowercase and
preceding them with an underscore. In fact, this is just how all the
predefined node types are defined – those node types are not “special”;
they&#39;re defined in the source file
<code>xml/mapping/standard_nodes.rb</code> and then registered normally in
<code>xml/mapping.rb</code>. The source code of the built-in nodes is not
very long or complicated; you may consider reading it in addition to this
text to gain a better understanding.</p>

<h3 id="label-How+Node+Types+Work">How Node Types Work<span><a href="#label-How+Node+Types+Work">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The xml-mapping core “operates” node types as follows:</p>

<h4 id="label-Node+Initialization">Node Initialization<span><a href="#label-Node+Initialization">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>As said above, when a node class is registered with xml-mapping by calling
<code>XML::Mapping.add_node_class TheNodeClass</code>, xml-mapping
automatically generates the node factory method for that type. The node
factory method will effectively be defined as a class method of the
XML::Mapping module, which is why one can call it from the body of a
mapping class definition. The generated method will create a new instance
of the node class (a <em>node</em> for short) by calling <em>new</em> on
the node class. The list of parameters to <em>new</em> will consist of
<em>the mapping class, followed by all arguments that were passed to the
node factory method</em>. For example, when you have this node declaration:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyMappingClass</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Mapping</span>

  <span class="ruby-identifier">my_node</span> :<span class="ruby-identifier">foo</span>, <span class="ruby-string">&quot;bar&quot;</span>, <span class="ruby-value">42</span>, :<span class="ruby-identifier">hi=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;ho&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>, then the node factory method (<code>my_node</code>) calls
<code>MyNode.new(MyMappingClass, :foo, &quot;bar&quot;, 42,
:hi=&gt;&quot;ho&quot;)</code>.</p>

<p><em>new</em> of course creates the instance and calls <em>initialize</em>
on it. The <em>initialize</em> implementation will generally store the
parameters into some instance variables for later usage. As a convention,
<em>initialize</em> should always extract from the parameter list those
parameters it processes itself, process them, and return an array
containing the remaining (still unprocessed) parameters. Thus, an
implementation of <em>initialize</em> follows this pattern:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">myparam1</span>,<span class="ruby-identifier">myparam2</span>,<span class="ruby-operator">...</span>,<span class="ruby-identifier">myparamx</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">args</span> = <span class="ruby-keyword">super</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)

  <span class="ruby-operator">...</span>. <span class="ruby-identifier">process</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">myparam1</span>,<span class="ruby-identifier">myparam2</span>,<span class="ruby-operator">...</span>,<span class="ruby-identifier">myparamx</span> <span class="ruby-operator">...</span>.

  <span class="ruby-comment"># return still unprocessed args</span>
  <span class="ruby-identifier">args</span>
<span class="ruby-keyword">end</span>
</pre>

<p>(since the called superclass initializer is written the same way, the
parameter array returned by it will already be stripped of all parameters
that the superclass initializer (or any of its superclasses&#39;s
initializers) processed)</p>

<p>This technique is a simple way to “chain” the initializers of all
superclasses of a node class, starting with the topmost one (Node), so that
each initializer can easily find out and process the parameters it is
responsible for.</p>

<p>The base node class <a href="XML/Mapping/Node.html">XML::Mapping::Node</a>
provides an <em>initialize</em> implementation that, among other things
(described below), adds <em>self</em> (i.e. the created node) to the
internal list of nodes held by the mapping class, and sets the @owner
attribute of <em>self</em> to reference the mapping class.</p>

<p>So, effectively there will be one instance of a node class (a node) per
node definition, and that instance lives in the mapping class the node was
defined in.</p>

<h4 id="label-Node+Operation+during+Marshalling+and+Unmarshalling">Node Operation during Marshalling and Unmarshalling<span><a href="#label-Node+Operation+during+Marshalling+and+Unmarshalling">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>When an instance of a mapping class is created or filled from an <a
href="XML.html">XML</a> tree, xml-mapping will call <code>xml_to_obj</code>
on all nodes defined in that mapping class in the <a
href="aref:mappings">mapping</a> the node is defined in, in the order of
their definition. Two parameters will be passed: the mapping class instance
being created/filled, and the <a href="XML.html">XML</a> tree the instance
is being created/filled from. The implementation of <code>xml_to_obj</code>
is expected to read whatever pieces of data it is responsible for from the
<a href="XML.html">XML</a> tree and put it into the appropriate
variables/attributes etc. of the instance.</p>

<p>When an instance of a mapping class is stored or filled into an <a
href="XML.html">XML</a> tree, xml-mapping will call <code>obj_to_xml</code>
on all nodes defined in that mapping class in the <a
href="aref:mappings">mapping</a> the node is defined in, in the order of
their definition, again passing as parameters the mapping class instance
being stored, and the <a href="XML.html">XML</a> tree the instance is being
stored/filled into. The implementation of <code>obj_to_xml</code> is
expected to read whatever pieces of data it is responsible for from the
instance and put it into the appropriate <a href="XML.html">XML</a>
elements/XML attr etc. of the <a href="XML.html">XML</a> tree.</p>

<h3 id="label-Basic+Node+Types+Overview">Basic Node Types Overview<span><a href="#label-Basic+Node+Types+Overview">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The following is an overview of how initialization and
marshalling/unmarshalling is implemented in the node base classes (Node,
SingleAttributeNode, and SubObjectBaseNode).</p>

<p>TODO: summary table: member var name; introduced in class; meaning</p>

<h4 id="label-Node">Node<span><a href="#label-Node">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>In <em>initialize</em>, the mapping class and the option arguments are
stripped from the argument list. The mapping class is stored in @owner, the
option arguments are stored (as a hash) in @options (the hash will be empty
if no options were given). The <a href="aref:mappings">mapping</a> the node
is defined in is determined (:mapping option, last <code>use_mapping</code>
or <code>:_default</code>) and stored in @mapping. The node then stores
itself in the list of nodes of the mapping class belonging to the mapping
(<code>@owner.xml_mapping_nodes(:mapping=&gt;@mapping)</code>; see <a
href="XML/Mapping/ClassMethods.html#method-i-xml_mapping_nodes">XML::Mapping::ClassMethods#xml_mapping_nodes</a>).
This list is the list of nodes later used when marshalling/unmarshalling an
instance of the mapping class with respect to a given mapping. This means
that node implementors will not normally “see” anything of the mapping
(they don&#39;t need to access the @mapping variable) because the
marshalling/unmarshalling methods
(<code>obj_to_xml</code>/<code>xml_to_obj</code>) simply won&#39;t be
called if the node&#39;s mapping is not the same as the mapping the
marshalling/unmarshalling is happening with.</p>

<p>Furthermore, if :reader and/or :writer options were given,
<code>xml_to_obj</code> resp. <code>obj_to_xml</code> are transparently
overwritten on the node to delegate to the supplied :reader/:writer procs.</p>

<p>The marshalling/unmarshalling methods
(<code>obj_to_xml</code>/<code>xml_to_obj</code>) are not implemented in
<code>Node</code> (they just raise an exception).</p>

<h4 id="label-SingleAttributeNode">SingleAttributeNode<span><a href="#label-SingleAttributeNode">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>In <em>initialize</em>, the attribute name is stripped from the argument
list and stored in @attrname, and an attribute of that name is added to the
mapping class the node belongs to.</p>

<p>During marshalling/unmarshalling of an object to/from <a
href="XML.html">XML</a>, single-attribute nodes only read/write a single
piece of the object&#39;s state: the single attribute (@attrname) the node
handles. Because of this, the
<code>obj_to_xml</code>/<code>xml_to_obj</code> implementations in
SingleAttributeNode call two new methods introduced by SingleAttributeNode,
which must be overwritten by subclasses:</p>

<pre>extract_attr_value(xml)

set_attr_value(xml, value)</pre>

<p><code>extract_attr_value(xml)</code> is called by <code>xml_to_obj</code>
during unmarshalling. <em>xml</em> is the <a href="XML.html">XML</a> tree
being read. The method must read the attribute&#39;s value from
<em>xml</em> and return it. <code>xml_to_obj</code> will set the attribute
to that value.</p>

<p><code>set_attr_value(xml, value)</code> is called by
<code>obj_to_xml</code> during marshalling. <em>xml</em> is the <a
href="XML.html">XML</a> tree being written, <em>value</em> is the current
value of the attribute. The method must write <em>value</em> into (the
correct sub-elements/attributes) of <em>xml</em>.</p>

<p>SingleAttributeNode also handles the default value, if it was specified
(via the :default_value option): When writing data to <a
href="XML.html">XML</a>, <code>set_attr_value(xml, value)</code> won&#39;t
be called if the attribute was set to the default value. When reading data
from <a href="XML.html">XML</a>, the <code>extract_attr_value(xml)</code>
implementation must raise a special exception, <a
href="XML/Mapping/SingleAttributeNode/NoAttrValueSet.html">XML::Mapping::SingleAttributeNode::NoAttrValueSet</a>,
if it wants to indicate that the data was not present in the <a
href="XML.html">XML</a>. SingleAttributeNode will catch this exception and
put the default value, if it was defined, into the attribute.</p>

<h4 id="label-SubObjectBaseNode">SubObjectBaseNode<span><a href="#label-SubObjectBaseNode">&para;</a> <a href="#documentation">&uarr;</a></span></h4>

<p>The initializer will set up additional member variables @sub_mapping,
@marshaller, and @unmarshaller.</p>

<p>@sub_mapping contains the mapping to be used when reading/writing the
sub-objects (either specified with :sub_mapping, or, by default, the
mapping the node itself was defined in).</p>

<p>@marshaller and @unmarshaller contain procs that encapsulate
writing/reading of sub-objects to/from <a href="XML.html">XML</a>, as
specified by the user with :class/:marshaller/:unmarshaller etc. options
(the meaning of those different options was described <a
href="aref:subobjnodes">above</a>). The procs are there to be called from
<code>extract_attr_value</code> or <code>set_attr_value</code> whenever the
need arises.</p>

<h2 id="label-XPath+Interpreter">XPath Interpreter<span><a href="#label-XPath+Interpreter">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p><a href="XML/XXPath.html">XML::XXPath</a> is an XPath parser. It is used in
xml-mapping node type definitions, but can just as well be utilized
stand-alone (it does not depend on xml-mapping). <a
href="XML/XXPath.html">XML::XXPath</a> is very incomplete and probably will
always be, but it should be reasonably efficient (XPath expressions are
precompiled), and, most importantly, it supports write access, which is
needed for writing objects to <a href="XML.html">XML</a>. For example, if
you create the path <code>/foo/bar[3]/baz[@key='hiho']</code> in the <a
href="XML.html">XML</a> document</p>

<pre>&lt;foo&gt;
  &lt;bar&gt;
    &lt;baz key=&quot;ab&quot;&gt;hello&lt;/baz&gt;
    &lt;baz key=&quot;xy&quot;&gt;goodbye&lt;/baz&gt;
  &lt;/bar&gt;
&lt;/foo&gt;</pre>

<p>, you&#39;ll get:</p>

<pre>&lt;foo&gt;
  &lt;bar&gt;
    &lt;baz key=&#39;ab&#39;&gt;hello&lt;/baz&gt;
    &lt;baz key=&#39;xy&#39;&gt;goodbye&lt;/baz&gt;
  &lt;/bar&gt;
  &lt;bar/&gt;
  &lt;bar&gt;
    &lt;baz key=&#39;hiho&#39;/&gt;
  &lt;/bar&gt;
&lt;/foo&gt;</pre>

<p><a href="XML/XXPath.html">XML::XXPath</a> is explained in more detail in
the reference documentation and the <a
href="user_manual_xxpath_md.html">user_manual_xxpath</a> file.</p>

<h2 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<p>xml-mapping is licensed under the Apache License, version 2.0. See the
LICENSE file for details.</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

